<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>InsertSort-插入排序</title>
    <url>/archives/20135.html</url>
    <content><![CDATA[<blockquote>
<p>​    老实讲，自己算法水平就是个战五渣，大二数据结构学的还行，但是过了一学期也记忆模糊，加上从来没有接触过算法训练，而且下学期的算法课……</p>
<p>​    种种原因促使我得靠假期恶补下自己的算法水平，算法还是用c++写吧，java总觉得怪怪的，类似于拿着叉子吃面？也算是个人偏见吧==</p>
</blockquote>
<a id="more"></a>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Name: InsertSort 插入排序 </span></span><br><span class="line"><span class="comment">	Copyright: SUST </span></span><br><span class="line"><span class="comment">	Author: SunnyGrocery  </span></span><br><span class="line"><span class="comment">	Date: 12/07/19 00:49</span></span><br><span class="line"><span class="comment">	Description: 空间复杂度要求为O(1)  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>* random)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; R ;<span class="comment">//random</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S ;<span class="comment">//sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i ;i&lt;SIZE;i++)&#123;</span><br><span class="line">        R.push(random[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出待排序栈栈顶元素 ,以临时变量t保存 </span></span><br><span class="line">    <span class="keyword">int</span> t = R.top();R.pop();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *(!S.empty() &amp;&amp; S.top() &gt; t)是为了当判定当R为空时，t是否小于S的栈顶元素</span></span><br><span class="line"><span class="comment">    *如果小于，则还需要进入循环(首先进入else),直到最后当R为空时，t将大于有序列的栈顶元素</span></span><br><span class="line"><span class="comment">    *保证了将最后的t压入时，S不受最后t的影响，仍有序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(!R.empty() || (!S.empty() &amp;&amp; t &lt; S.top()))&#123;</span><br><span class="line">        <span class="comment">//小于等于号保证了此算法为稳定排序 </span></span><br><span class="line">        <span class="keyword">if</span>(S.empty()||S.top() &lt;= t)&#123;</span><br><span class="line">            S.push(t);<span class="comment">//有序列压入t</span></span><br><span class="line">            t = R.top(); R.pop();<span class="comment">//更新t </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            R.push(S.top());S.pop();<span class="comment">//显然S不为空，若t比S栈顶元素小则 将S中元素放入R中暂存 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最后的t压入S中 </span></span><br><span class="line">    S.push(t);</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> random[SIZE] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; T = insertSort(random);</span><br><span class="line">	<span class="keyword">while</span>(!T.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T.top()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		T.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop快速入门指南</title>
    <url>/archives/31833.html</url>
    <content><![CDATA[<blockquote>
<p>文章多处参考自<span class="exturl" data-url="aHR0cHM6Ly9oYWRvb3AuYXBhY2hlLm9yZy9kb2NzL3N0YWJsZS9oYWRvb3AtcHJvamVjdC1kaXN0L2hhZG9vcC1jb21tb24vU2luZ2xlQ2x1c3Rlci5odG1s">Hadoop: Setting up a Single Node Cluster<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>注意：测试环境中应有3台虚拟机，各自网卡UUID，IP，主机名均不同，一下信息仅为其中之一的配置</p>
<h2 id="虚拟机信息"><a href="#虚拟机信息" class="headerlink" title="虚拟机信息"></a>虚拟机信息</h2><ul>
<li><p>CentOS Linux release 7.6.1810 (Core) </p>
<p>Derived from Red Hat Enterprise Linux 7.6 (Source)</p>
<p>Linux hadoop10 3.10.0-957.27.2.el7.x86_64</p>
</li>
<li><p>账户信息</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>用户名</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>sun</td>
<td>123456</td>
</tr>
<tr>
<td>hadoop</td>
<td>123456</td>
</tr>
<tr>
<td>root</td>
<td>123456</td>
</tr>
</tbody></table>
<ul>
<li>测试hadoop时务必使用hadoop用户操作</li>
</ul>
<a id="more"></a>

<h2 id="网络配置详情"><a href="#网络配置详情" class="headerlink" title="网络配置详情"></a>网络配置详情</h2><h3 id="虚拟机外围配置"><a href="#虚拟机外围配置" class="headerlink" title="虚拟机外围配置"></a>虚拟机外围配置</h3><blockquote>
<p>环境：VMware® Workstation 15 Pro 15.0.0 build-10134415</p>
</blockquote>
<ul>
<li>虚拟网络VMnet配置</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>外部链接</th>
<th>主机连接</th>
<th>DHCP</th>
<th>子网地址</th>
</tr>
</thead>
<tbody><tr>
<td>VMnet8</td>
<td>NAT模式</td>
<td>NAT模式</td>
<td>已连接</td>
<td>-</td>
<td>192.169.100.0</td>
</tr>
</tbody></table>
<ul>
<li><p>关闭DHCP服务</p>
</li>
<li><p>子网IP：192.168.100.0             子网掩码：255.255.255.0</p>
</li>
<li><p>网关IP：192.168.100.2</p>
</li>
<li><p>关闭IPV6</p>
</li>
</ul>
<!--more-->

<h3 id="虚拟机内配置"><a href="#虚拟机内配置" class="headerlink" title="虚拟机内配置"></a>虚拟机内配置</h3><ul>
<li><p>ip addr</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">1</span>: <span class="string">lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span></span><br><span class="line">    <span class="meta">link/loopback</span> <span class="string">00:00:00:00:00:00 brd 00:00:00:00:00:00</span></span><br><span class="line">    <span class="attr">inet</span> <span class="string">127.0.0.1/8 scope host lo</span></span><br><span class="line">       <span class="attr">valid_lft</span> <span class="string">forever preferred_lft forever</span></span><br><span class="line">    <span class="attr">inet6</span> :<span class="string">:1/128 scope host </span></span><br><span class="line">       <span class="attr">valid_lft</span> <span class="string">forever preferred_lft forever</span></span><br><span class="line"><span class="attr">2</span>: <span class="string">ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></span><br><span class="line">    <span class="meta">link/ether</span> <span class="string">00:0c:29:f1:16:d2 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line">    <span class="attr">inet</span> <span class="string">192.168.100.10/24 brd 192.168.100.255 scope global noprefixroute ens33</span></span><br><span class="line">       <span class="attr">valid_lft</span> <span class="string">forever preferred_lft forever</span></span><br><span class="line">    <span class="attr">inet6</span> <span class="string">fe80::711a:c906:a3e3:aed6/64 scope link noprefixroute </span></span><br><span class="line">       <span class="attr">valid_lft</span> <span class="string">forever preferred_lft forever</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>主要网络信息<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">static</span></span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="string">192.168.100.10</span></span><br><span class="line"><span class="attr">NETMASK</span>=<span class="string">255.255.255.0</span></span><br><span class="line"><span class="attr">GATEWAY</span>=<span class="string">192.168.100.2</span></span><br><span class="line"><span class="attr">DNS1</span>=<span class="string">114.114.114.114</span></span><br><span class="line"><span class="attr">DNS2</span>=<span class="string">8.8.8.8</span></span><br></pre></td></tr></table></figure></li>
<li><p>主机名<code>/etc/sysconfig/network</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">NETWORKING</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">HOSTNAME</span>=<span class="string">hadoop10</span></span><br></pre></td></tr></table></figure></li>
<li><p>HOSTS<code>/etc/hosts</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">127.0.0.1</span>   <span class="string">localhost localhost.localdomain localhost4 localhost4.localdomain4</span></span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"><span class="meta">192.168.100.10</span> <span class="string">hadoop10</span></span><br><span class="line"><span class="meta">192.168.100.11</span> <span class="string">hadoop11</span></span><br><span class="line"><span class="meta">192.168.100.12</span> <span class="string">hadoop12    </span></span><br></pre></td></tr></table></figure>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2></li>
<li><p>hadoop和jdk存放目录（注意 /opt 下的所有文件所有者一定是用户hadoop）</p>
<p><code>tree -L 1 /opt/modules/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;opt&#x2F;modules&#x2F;</span><br><span class="line">├── hadoop-3.1.2</span><br><span class="line">└── jdk1.8.0_201</span><br></pre></td></tr></table></figure></li>
<li><p>环境变量</p>
<p><code>cat /etc/profile | tail -n 9</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#java</span></span><br><span class="line"><span class="attr">export</span> <span class="string">JAVA_HOME=/opt/modules/jdk1.8.0_201</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=$JAVA_HOME/bin:$PATH</span></span><br><span class="line"><span class="attr">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hadoop</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HADOOP_HOME=/opt/modules/hadoop-3.1.2</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span></span><br></pre></td></tr></table></figure>
<h2 id="示例运行"><a href="#示例运行" class="headerlink" title="示例运行"></a>示例运行</h2></li>
</ul>
<h4 id="一、Standalone-Operation-单机运算"><a href="#一、Standalone-Operation-单机运算" class="headerlink" title="一、Standalone Operation 单机运算"></a>一、Standalone Operation 单机运算</h4><blockquote>
<p>By default, Hadoop is configured to run in a non-distributed mode, as a single Java process. This is useful for debugging.</p>
<p>The following example copies the unpacked conf directory to use as input and then finds and displays every match of the given regular expression. Output is written to the given output directory.</p>
</blockquote>
<p><strong>Ⅰ.Grep</strong></p>
<ol>
<li><p>创建输入文件（pwd /opt/modules/hadoop-3.1.2/）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ mkdir input</span><br><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ cp etc/hadoop/*.xml input</span><br></pre></td></tr></table></figure></li>
<li><p>目录结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ tree input/</span><br><span class="line">input/</span><br><span class="line">├── capacity-scheduler.xml</span><br><span class="line">├── core-site.xml</span><br><span class="line">├── hadoop-policy.xml</span><br><span class="line">├── hdfs-site.xml</span><br><span class="line">├── httpfs-site.xml</span><br><span class="line">├── kms-acls.xml</span><br><span class="line">├── kms-site.xml</span><br><span class="line">├── mapred-site.xml</span><br><span class="line">└── yarn-site.xml</span><br></pre></td></tr></table></figure></li>
<li><p>启动示例（这里注意，output目录如果已经存在则会报错）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.2.jar grep input output &#x27;dfs[a-z.]+&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>结果（筛选符合正则的文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ output/part-r-00000 </span><br><span class="line">1	dfsadmin</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Ⅱ.WordCount</strong></p>
<ol>
<li><p>创建输入文件（pwd /opt/modules/hadoop-3.1.2/）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ mkdir wcinput</span><br><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ cd wcinput</span><br><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ touch wc.input</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">以下是向wc.input中添加的内容</span></span><br><span class="line">hadoop mark</span><br><span class="line">hadoop yarn</span><br><span class="line">sun key  </span><br><span class="line">sun key</span><br></pre></td></tr></table></figure></li>
<li><p>启动示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@hadoop10 hadoop-3.1.2]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.2.jar wordcount wcinput wcoutput</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ cat wcoutput/part-r-00000 </span><br><span class="line">hadoop	2</span><br><span class="line">key	2</span><br><span class="line">mark	1</span><br><span class="line">sun	2</span><br><span class="line">yarn	1</span><br></pre></td></tr></table></figure>
<h4 id="二、Pseudo-Distributed-Operation-伪分布运算"><a href="#二、Pseudo-Distributed-Operation-伪分布运算" class="headerlink" title="二、Pseudo-Distributed Operation 伪分布运算"></a>二、Pseudo-Distributed Operation 伪分布运算</h4></li>
</ol>
<blockquote>
<p>Hadoop can also be run on a single-node in a pseudo-distributed mode where each Hadoop daemon runs in a separate Java process.</p>
</blockquote>
<ol>
<li><p>配置（pwd /opt/modules/hadoop-3.1.2/）</p>
<ul>
<li><code>vim etc/hadoop/core-site.xml</code>   </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   指定HDFS 中NameNode 的地址</span></span><br><span class="line"><span class="comment">   注意，因为示例一依赖的是linux文件系统，所以配置此项过后示例一将无法运行</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--规范来说应注意将localhost改为主机名--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop10:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   指定Hadoop 运行时产生文件的存储目录</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/modules/hadoop-3.1.2/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>etc/hadoop/hdfs-site.xml</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">配置文件副本数，默认为3</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置Hadoop的JAVA_HOME</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim etc/hadoop/hadoop-env.sh</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">添加/更改为</span></span><br><span class="line">export JAVA_HOME=/opt/modules/jdk1.8.0_201</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置ssh免密</p>
<p>Now check that you can ssh to the localhost without a passphrase:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh localhost</span></span><br></pre></td></tr></table></figure>
<p>If you cannot ssh to localhost without a passphrase, execute the following commands:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span> -f ~/.ssh/id_rsa</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 0600 ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure></li>
<li><p>格式化文件系统（Format the filesystem）</p>
<p>注意：只有第一次配置才需要格式化文件系统</p>
<p>因为配置过Hadoops /bin和/sbin下的环境变量，所以这里可以省略<code>bin/</code>和<code>sbin/</code>路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/hdfs namenode -format</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动NameNode和DataNode守护进程 (Start NameNode daemon and DataNode daemon)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ start-dfs.sh </span><br><span class="line">Starting namenodes on [hadoop10]</span><br><span class="line">Starting datanodes</span><br><span class="line">Starting secondary namenodes [hadoop10]</span><br><span class="line"><span class="meta">#</span><span class="bash">检查启动是否成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jps</span></span><br><span class="line">3080 SecondaryNameNode</span><br><span class="line">2746 NameNode</span><br><span class="line">3213 Jps</span><br><span class="line">2863 DataNode</span><br></pre></td></tr></table></figure></li>
<li><p>浏览器查看web页面：Browse the web interface for the NameNode; by default it is available at:</p>
<p>NameNode - <code>http://localhost:9870/</code></p>
</li>
<li><p>hdfs文件操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hdfs dfs -mkdir -p /home/hadoop/input、</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hdfs dfs -ls -R /</span></span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:30 /home</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:30 /home/hadoop</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:30 /home/hadoop/input</span><br><span class="line"><span class="meta">#</span><span class="bash">将linux文件传至hdfs文件系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hdfs dfs -put wcinput/wc.input /home/hadoop/input</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hdfs dfs -ls -R /</span></span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:30 /home</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:30 /home/hadoop</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:34 /home/hadoop/input</span><br><span class="line">-rw-r--r--   1 hadoop supergroup         42 2019-09-22 01:34 /home/hadoop/input/wc.input</span><br></pre></td></tr></table></figure></li>
<li><p>WordCount示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行示例(记得output先删除掉)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.2.jar wordcount /home/hadoop/input/wc.input /home/hadoop/output</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看生成结果</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hdfs dfs -ls -R /</span></span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:30 /home</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:43 /home/hadoop</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:34 /home/hadoop/input</span><br><span class="line">-rw-r--r--   1 hadoop supergroup         42 2019-09-22 01:34 /home/hadoop/input/wc.input</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-09-22 01:43 /home/hadoop/output</span><br><span class="line">-rw-r--r--   1 hadoop supergroup          0 2019-09-22 01:43 /home/hadoop/output/_SUCCESS</span><br><span class="line">-rw-r--r--   1 hadoop supergroup         35 2019-09-22 01:43 /home/hadoop/output/part-r-00000</span><br><span class="line"><span class="meta">#</span><span class="bash">查看输出结果</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hdfs dfs -cat /home/hadoop/output/part*</span></span><br><span class="line">hadoop	2</span><br><span class="line">key	2</span><br><span class="line">mark	1</span><br><span class="line">sun	2</span><br><span class="line">yarn	1</span><br></pre></td></tr></table></figure>
<h3 id="三、YARN-on-a-Single-Node-单节点YARN"><a href="#三、YARN-on-a-Single-Node-单节点YARN" class="headerlink" title="三、YARN on a Single Node 单节点YARN"></a>三、YARN on a Single Node 单节点YARN</h3></li>
<li><p>配置（pwd /opt/modules/hadoop-3.1.2/）</p>
<ul>
<li><code>vim etc/hadoop/mapred-site.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定mapreduce使用yarn--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>vim etc/hadoop/yarn-site.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Reducer 获取数据的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定YARN 的ResourceManager 的地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动ResourceManager和NodeManager守护进程 （Start ResourceManager daemon and NodeManager daemon）</p>
</li>
</ol>
<ul>
<li><code>start-yarn.sh</code></li>
</ul>
<ol start="3">
<li><p>查看进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ jps</span><br><span class="line">10800 Jps</span><br><span class="line">9988 ResourceManager</span><br><span class="line">5432 SecondaryNameNode</span><br><span class="line">5230 DataNode</span><br><span class="line">5119 NameNode</span><br><span class="line">10095 NodeManager</span><br></pre></td></tr></table></figure></li>
<li><p>浏览器查看web页面：Browse the web interface for the ResourceManager; by default it is available at:</p>
<ul>
<li>ResourceManager - <code>http://localhost:8088/</code></li>
</ul>
</li>
<li><p>WordCount示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.2.jar wordcount /home/hadoop/input/wc.input /home/hadoop/output</span><br></pre></td></tr></table></figure></li>
<li><p>查看结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ hdfs dfs -cat /home/hadoop/output/part-r-00000</span><br><span class="line">hadoop	2</span><br><span class="line">key	2</span><br><span class="line">mark	1</span><br><span class="line">sun	2</span><br><span class="line">yarn	1</span><br></pre></td></tr></table></figure>
<h3 id="四、历史服务器"><a href="#四、历史服务器" class="headerlink" title="四、历史服务器"></a>四、历史服务器</h3></li>
<li><p>配置mapred-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--历史服务器端地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop10:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 历史服务器web 端地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop10:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>运行Jobhistoryserver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ mapred --daemon start historyserver</span><br></pre></td></tr></table></figure></li>
<li><p>查看进程 | 访问<code>http://hadoop10:19888/</code> 查看 jobhistory</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop10 hadoop-3.1.2]$ jps</span><br><span class="line">1408 NameNode</span><br><span class="line">2096 NodeManager</span><br><span class="line">3216 JobHistoryServer</span><br><span class="line">1970 ResourceManager</span><br><span class="line">1525 DataNode</span><br><span class="line">1736 SecondaryNameNode</span><br><span class="line">3309 Jps</span><br></pre></td></tr></table></figure>
<h3 id="五、日志聚集"><a href="#五、日志聚集" class="headerlink" title="五、日志聚集"></a>五、日志聚集</h3></li>
</ol>
<blockquote>
<p>简单记一下吧，其实都一样</p>
</blockquote>
<ol>
<li><p>配置yarn_site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志聚集功能使能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志保留时间设置7 天--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Reducer 获取数据的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定YARN 的ResourceManager 的地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>关闭yarn(这里可以不重启hdfs和jobhistoryserver)</p>
</li>
<li><p>这里我删除了hdfs 下yarn生成的tmp文件，和原来wordcount输出的output文件</p>
</li>
<li><p>重启yarn</p>
</li>
<li><p>启动WordCount示例</p>
</li>
<li><p>访问<code>http://hadoop10:19888/jobhistory</code></p>
</li>
<li><p>找到刚刚完成的WordCount Job，应该也就一个</p>
<p><img src="http://image.sun1999.top/20190923223921.png"></p>
</li>
<li><p>进入log<br><img src="http://image.sun1999.top/20190923224032.png"></p>
</li>
<li><p>查看log,是这个亚子~<br> <img src="http://image.sun1999.top/20190923224204.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>NTP—服务端＆客户端搭建指南</title>
    <url>/archives/43160.html</url>
    <content><![CDATA[<h3 id="◈NTP是什么"><a href="#◈NTP是什么" class="headerlink" title="◈NTP是什么"></a>◈NTP是什么</h3><ul>
<li>网络时间协议（英语：Network Time Protocol，缩写：NTP）是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于OSI模型的应用层。自1985年以来，NTP是当前仍在使用的最古老的互联网协议之一。NTP由特拉华大学的David L. Mills设计。</li>
<li>计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，以选择最佳的路径和来源以便校正主机时间。即使在主机长时间无法与某一时钟服务器联系的情况下，NTP服务依然可以有效运转。</li>
</ul>
<a id="more"></a>

<h3 id="◈服务端"><a href="#◈服务端" class="headerlink" title="◈服务端"></a>◈服务端</h3><ol>
<li><p>安装NTP服务器（以下命令都再root权限下执行）</p>
<p><code>yum install ntp</code></p>
</li>
<li><p>先做一次强制同步（注意：<code>ntpdate</code>和<code>ntpd</code>为两种同步策略，下面会细讲）</p>
<p><code>ntpdate cn.pool.ntp.org</code></p>
</li>
<li><p>更改配置文件</p>
<p><code>vim /etc/ntp.conf </code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driftfile</span> <span class="string">/var/lib/ntp/drift</span></span><br><span class="line"><span class="attr">restrict</span> <span class="string">default nomodify notrap nopeer noquery</span></span><br><span class="line"><span class="comment">#放行主机</span></span><br><span class="line"><span class="attr">restrict</span> <span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">restrict</span> :<span class="string">:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#放行局域网 192.168.100 段可以来同步本服务端的时间</span></span><br><span class="line"><span class="attr">restrict</span> <span class="string">192.168.100.0 mask 255.255.255.0 nomodify notrap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#放一些能用的</span></span><br><span class="line"><span class="attr">server</span> <span class="string">210.72.145.44</span></span><br><span class="line"><span class="attr">server</span> <span class="string">202.112.10.36</span></span><br><span class="line"><span class="attr">server</span> <span class="string">59.124.196.83</span></span><br><span class="line"><span class="attr">server</span> <span class="string">0.cn.pool.ntp.org</span></span><br><span class="line"><span class="attr">server</span> <span class="string">1.cn.pool.ntp.org</span></span><br><span class="line"><span class="attr">server</span> <span class="string">2.cn.pool.ntp.org</span></span><br><span class="line"><span class="attr">server</span> <span class="string">3.cn.pool.ntp.org</span></span><br><span class="line"><span class="comment">#这里如果将以上server全部注释，并开启下面的注释</span></span><br><span class="line"><span class="comment">#会采用本机时间作为时间服务器为集群中的其他节点提供时间同步，其实也可以</span></span><br><span class="line"><span class="comment">#server 127.127.1.0</span></span><br><span class="line"><span class="comment">#fudge 127.127.1.0 stratum 10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">includefile</span> <span class="string">/etc/ntp/crypto/pw</span></span><br><span class="line"><span class="attr">keys</span> <span class="string">/etc/ntp/keys</span></span><br></pre></td></tr></table></figure>
<p><code>vim /etc/sysconfig/ntpd</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加BIOS时间同步</span></span><br><span class="line"><span class="attr">SYNC_HWCLOCK</span>=<span class="string">yes</span></span><br></pre></td></tr></table></figure></li>
<li><p>开启并检查服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.第一次，查看服务器同步状态（注意这里本机还没有开启服务器）</span></span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpstat</span></span><br><span class="line">synchronised to NTP server (119.28.206.193) at stratum 3</span><br><span class="line">   time correct to within 869 ms</span><br><span class="line">   polling server every 64 s</span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpq -p</span></span><br><span class="line">ntpq: <span class="built_in">read</span>: Connection refused</span><br><span class="line"><span class="comment">#2.开启服务器</span></span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># systemctl start ntpd</span></span><br><span class="line"><span class="comment">#3.第二次，查看服务器同步状态（并未同步成功，这里需要等待5-10min左右）</span></span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpstat</span></span><br><span class="line">unsynchronised</span><br><span class="line">   polling server every 64 s</span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpq -p</span></span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line"> 45.124.64.93    .STEP.          16 u    -   64    0    0.000    0.000   0.000</span><br><span class="line"> electrode.felix 56.1.129.236     3 u    2   64    1  387.564    1.610   0.000</span><br><span class="line"> tock.ntp.infoma .GPS.            1 u    2   64    1  366.394   23.747   0.000</span><br><span class="line"> ntp1.ams1.nl.le 130.133.1.10     2 u    3   64    0    0.000    0.000   0.000</span><br><span class="line"><span class="comment">#4.第三次，查看服务器状态（注意ntpq -p已经选择好了服务器，但仍未同步成功）</span></span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpstat</span></span><br><span class="line">unsynchronised</span><br><span class="line">   polling server every 64 s</span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpq -p</span></span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line"> 45.124.64.93    .STEP.          16 u    -   64    0    0.000    0.000   0.000</span><br><span class="line">+electrode.felix 56.1.129.236     3 u   83   64    1  393.182   -0.273   1.488</span><br><span class="line">*tock.ntp.infoma .GPS.            1 u   21   64    1  365.134   25.103   4.323</span><br><span class="line">+ntp1.ams1.nl.le 130.133.1.10     2 u   21   64    1  386.136   15.690   6.699</span><br><span class="line"><span class="comment">#第四次，查看服务器状态（同步成功）</span></span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpstat</span></span><br><span class="line">synchronised to NTP server (84.16.67.12) at stratum 2</span><br><span class="line">   time correct to within 224 ms</span><br><span class="line">   polling server every 64 s</span><br><span class="line">[root@hadoop10 hadoop]<span class="comment"># ntpq -p</span></span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line">+45.124.64.93    236.43.203.76    2 u   62   64  377  248.017   16.850   6.243</span><br><span class="line">-electrode.felix 56.1.129.236     3 u   15   64  377  389.168    9.956   6.210</span><br><span class="line">*tock.ntp.infoma .GPS.            1 u   18   64  377  370.122   34.438   4.234</span><br><span class="line">+ntp1.ams1.nl.le 130.133.1.10     2 u   14   64  377  379.225   23.871   7.190</span><br></pre></td></tr></table></figure></li>
<li><p>配置开机自启<code>ntpd</code>服务</p>
<p><code>systemctl enable ntpd</code></p>
</li>
</ol>
<p><strong>至此，服务端配置完成</strong></p>
<h3 id="◈客户端"><a href="#◈客户端" class="headerlink" title="◈客户端"></a>◈客户端</h3><ol>
<li><p>安装NTP服务器（以下命令都再root权限下执行）</p>
<p><code>yum install ntp</code></p>
</li>
<li><p>强制同步到刚刚配置的服务端（刚才的服务器在我的环境中是192.168.100.11，当然如果hosts文件中配置过，可以直接用域名）</p>
<p><code>ntpdate hadoop10</code></p>
</li>
<li><p>配置同步，<strong>分为以下两种方法</strong></p>
</li>
</ol>
<p><strong>方法一</strong></p>
<ol>
<li><p>更改配置文件</p>
<p><code>vim /etc/ntp.conf </code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driftfile</span> <span class="string">/var/lib/ntp/drift</span></span><br><span class="line"></span><br><span class="line"><span class="attr">restrict</span> <span class="string">default nomodify notrap nopeer noquery</span></span><br><span class="line"></span><br><span class="line"><span class="attr">restrict</span> <span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">restrict</span> :<span class="string">:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只配置将服务器上游同步到局域网中自有的服务端</span></span><br><span class="line"><span class="comment">#perfer 表示优先此地址</span></span><br><span class="line"><span class="attr">server</span> <span class="string">hadoop10 perfer</span></span><br><span class="line"><span class="comment">##同样这里可以同步到其他的服务器，但建议不开，或者最多开个本机也行</span></span><br><span class="line"></span><br><span class="line"><span class="attr">includefile</span> <span class="string">/etc/ntp/crypto/pw</span></span><br><span class="line"><span class="attr">keys</span> <span class="string">/etc/ntp/keys</span></span><br></pre></td></tr></table></figure>
<p><code>vim /etc/sysconfig/ntpd</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加BIOS时间同步</span></span><br><span class="line"><span class="attr">SYNC_HWCLOCK</span>=<span class="string">yes</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置服务器环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.开启服务器</span></span><br><span class="line">[root@hadoop13 hadoop]<span class="comment"># systemctl start ntpd</span></span><br><span class="line"><span class="comment">#2.查询状态</span></span><br><span class="line">[root@hadoop13 hadoop]<span class="comment"># ntpstat</span></span><br><span class="line">unsynchronised</span><br><span class="line">   polling server every 8 s</span><br><span class="line">[root@hadoop13 hadoop]<span class="comment"># ntpq -p</span></span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line"> hadoop10        84.16.67.12      2 u    9   64    1    1.613   10.422   0.000</span><br><span class="line"><span class="comment">#3.再次查询，同步成功</span></span><br><span class="line">[root@hadoop13 ~]<span class="comment"># ntpstat </span></span><br><span class="line">synchronised to NTP server (192.168.100.10) at stratum 3</span><br><span class="line">   time correct to within 653 ms</span><br><span class="line">   polling server every 64 s</span><br><span class="line">[root@hadoop13 ~]<span class="comment"># ntpq -p</span></span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line">*hadoop10        84.16.67.12      2 u   23   64  377    0.677    6.215   2.461</span><br></pre></td></tr></table></figure></li>
<li><p>配置开机自启<code>ntpd</code></p>
<p><code>systemctl enable ntpd</code></p>
</li>
</ol>
<p><strong>方法二</strong>(个人不推荐，但非常方便)</p>
<ol>
<li><p>配置定时任务（关于<code>crontab</code>怎么用，查下资料挺简单的）</p>
<p><code>crontab -e</code></p>
<p>添加以下文本并保存(作用是每10分钟强制同步一次)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/10 * * * * ntpdate hadoop10</span><br></pre></td></tr></table></figure></li>
<li><p>开启并开机启动<code>crontab</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop13 ~]<span class="comment"># systemctl restart crond</span></span><br><span class="line">[root@hadoop13 ~]<span class="comment"># systemctl enable crond</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>至此，客户端配置完成</strong></p>
<h3 id="◈拓展知识"><a href="#◈拓展知识" class="headerlink" title="◈拓展知识"></a>◈拓展知识</h3><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3d3dy5udHAub3JnLw==">NTP官方网站<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWVjaXMudWRlbC5lZHUvfm1pbGxzL250cC5odG1s">Network Time Synchronization Research Project<i class="fa fa-external-link-alt"></i></span> 官网详细的原理介绍</p>
</li>
<li><p>zh.wikipedia.org：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU4JUI3JUFGJUU2JTk5JTgyJUU5JTk2JTkzJUU1JThEJTk0JUU1JUFFJTlB">NTP网络时间协议<i class="fa fa-external-link-alt"></i></span> 需要梯子，非常推荐这篇文章，深入浅出，简单易懂</p>
</li>
</ul>
<ul>
<li><p><code>ntpd</code>和<code>ntpdate</code>的区别<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9hZGFpbGludXgvYmxvZy8xNjMzMjY0"> 转自 oschina：阿dai学长<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><code>ntpd</code>在实际同步时间时是一点点的校准过来时间的，最终把时间慢慢的校正对（平滑同步）</li>
<li><code>ntpdate</code>不会考虑其他程序是否会阵痛，直接调整时间（“跃变”）。</li>
<li>一个是校准时间，一个是调整时间。</li>
<li>“跃变”的危害：<ul>
<li>这样做不安全。ntpdate的设置依赖于ntp服务器的安全性，攻击者可以利用一些软件设计上的缺陷，拿下ntp服务器并令与其同步的服务器执行某些消耗性的任务。由于ntpdate采用的方式是跳变，跟随它的服务器无法知道是否发生了异常（时间不一样的时候，唯一的办法是以服务器为准）。</li>
<li>这样做不精确。一旦ntp服务器宕机，跟随它的服务器也就会无法同步时间。与此不同，ntpd不仅能够校准计算机的时间，而且能够校准计算机的时钟。</li>
<li>这样做不够优雅。由于是跳变，而不是使时间变快或变慢，依赖时序的程序会出错（例如，如果ntpdate发现你的时间快了，则可能会经历两个相同的时刻，对某些应用而言，这是致命的）。</li>
</ul>
</li>
</ul>
<p>因而，唯一一个可以令时间发生跳变的点，是计算机刚刚启动，但还没有启动很多服务的那个时候。其余的时候，理想的做法是使用ntpd来校准时钟，而不是调整计算机时钟上的时间。</p>
</li>
<li><p>NTP只同步时间戳，时区需要单独设置，以下命令Centos7下设置时区为<code>东八区</code></p>
<p><code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Linux</tag>
        <tag>NTP</tag>
      </tags>
  </entry>
  <entry>
    <title>完全分布式集群搭建</title>
    <url>/archives/39657.html</url>
    <content><![CDATA[<h3 id="集群分发脚本"><a href="#集群分发脚本" class="headerlink" title="集群分发脚本"></a>集群分发脚本</h3><ul>
<li>放在<code>~/bin/</code>下，注意需要配置可执行权限</li>
<li>for循环中配置节点主机名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1 获取输入参数个数，如果没有参数，直接退出</span></span><br><span class="line">pcount=$#</span><br><span class="line">if((pcount==0)); then</span><br><span class="line">echo no args;</span><br><span class="line">exit;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2 获取文件名称</span></span><br><span class="line">p1=$1</span><br><span class="line">fname=`basename $p1`</span><br><span class="line">echo fname=$fname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3 获取上级目录到绝对路径</span></span><br><span class="line">pdir=`cd -P $(dirname $p1); pwd`</span><br><span class="line">echo pdir=$pdir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4 获取当前用户名称</span></span><br><span class="line">user=`whoami`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5 循环</span></span><br><span class="line">for((host=11; host&lt;=13; host++)); do</span><br><span class="line">        echo ------------------- hadoop$host --------------</span><br><span class="line">        rsync -rvl $pdir/$fname $user@hadoop$host:$pdir</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><ol>
<li>集群部署规划<ul>
<li>这里注意NameNode、SecondaryNameNode、ResourceManager应分别放在不同服务器上</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>hadoop11</th>
<th>hadoop12</th>
<th>hadoop13</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>NameNode<br>DataNode</td>
<td>DataNode</td>
<td>SecondaryNameNode<br>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>ResourceManager<br>NodeManager</td>
<td>NodeManager<br/>JobHistoryServer</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>集群配置：(注意这里添改的配置信息均继承自<a href="https://www.sun1999.top/article/hadoop%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html">hadoop快速入门指南</a>一文）</p>
<ul>
<li><p>core-site.xml 将hdfs配置在hadoop11（NameNode节点）上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop11:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>hdfs-site.xml 指定hadoop辅助节点(SecondaryNameNode节点)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop13:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>yarn-site.xml 指定YARN 的ResourceManager 的地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop12<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>works 配置工作节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop11</span><br><span class="line">hadoop12</span><br><span class="line">hadoop13</span><br></pre></td></tr></table></figure></li>
<li><p>文末给出本教程打包配置文件</p>
</li>
</ul>
</li>
<li><p>配置SSH免密：</p>
<ul>
<li>ssh文件夹下（~/.ssh）的文件功能解释</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>known_hosts</th>
<th>记录ssh访问过计算机的公钥(public key)</th>
</tr>
</thead>
<tbody><tr>
<td>id_rsa</td>
<td>生成的私钥</td>
</tr>
<tr>
<td>id_rsa.pub</td>
<td>生成的公钥</td>
</tr>
<tr>
<td>authorized_keys</td>
<td>存放授权过得无密登录服务器公钥</td>
</tr>
</tbody></table>
<p>生成并发送密钥        </p>
<p>先把所有主机<code>~/.ssh/</code>下的文件都删掉，因为单节点当时配置过，当时只是为了能跑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop11 hadoop]$ ssh-keygen -t rsa</span><br><span class="line">[hadoop@hadoop11 hadoop]$ ssh-copy-id hadoop11</span><br><span class="line">[hadoop@hadoop11 hadoop]$ ssh-copy-id hadoop12</span><br><span class="line">[hadoop@hadoop11 hadoop]$ ssh-copy-id hadoop13</span><br></pre></td></tr></table></figure>
<h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><ol>
<li><p>第一次启动(不是第一次集群启动就跳过)：</p>
<ul>
<li><p>一定先停止所有的Namenode和Datanode服务(JPS查看,小心运行在root用户上)</p>
</li>
<li><p>如果有，删除所有集群上data与log下的文件</p>
</li>
<li><p>格式化NameNode<code>hdfs namenode -format</code></p>
</li>
</ul>
</li>
<li><p>HDFS启动：hadoop11下执行 <code>start-dfs.sh</code></p>
</li>
<li><p>Yarn启动：hadoop12下执行 <code>start-yarn.sh</code></p>
</li>
<li><p>JobHistoryServer：hadoop13下执行 <code>mapred --daemon start historyserver</code></p>
</li>
</ol>
<p><strong>至此，启动完毕，这里给出启动完成后各主机JPS进程情况</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop11</th>
<th>hadoop12</th>
<th>hadoop13</th>
</tr>
</thead>
<tbody><tr>
<td>JPS</td>
<td>3684 Jps<br/>3141 DataNode<br/>3019 NameNode<br/>3452 NodeManager</td>
<td>2900 ResourceManager<br/>2727 DataNode<br/>3031 NodeManager<br/>3448 Jps</td>
<td>2305 NodeManager<br/>2100 DataNode<br/>2184 SecondaryNameNode<br/>2906 JobHistoryServer<br/>3340 Jps</td>
</tr>
</tbody></table>
<h3 id="集群可用性检查"><a href="#集群可用性检查" class="headerlink" title="集群可用性检查"></a>集群可用性检查</h3><ul>
<li><code>http://hadoop11:9870/</code>跳转至NameNode管理页</li>
<li><code>http://hadoop12:8088/cluster</code>跳转至ResourceManager管理页</li>
<li><code>http://hadoop13:19888/</code>跳转至JobHistory管理页</li>
<li><code>$ hdfs dfs -put 本地路径 hdfs路径</code>上传一些测试文件，建议一大(&gt;128MB)一小</li>
<li>在9870下查看文件储存情况，查看下Block分块情况</li>
<li>还可以跑下wordcount~</li>
</ul>
<h3 id="关闭集群"><a href="#关闭集群" class="headerlink" title="关闭集群"></a>关闭集群</h3><ol>
<li><p>关闭 jobHistoryServer：hadoop13下 <code>mapred --daemon stop historyserver</code></p>
</li>
<li><p>关闭yarn：hadoop12下 <code>stop-yarn.sh</code></p>
</li>
<li><p>关闭hdfs：hadoop11下 <code>1stop-dfs.sh</code></p>
</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>这里给出一台虚拟机，从刚克隆到集群中配置过的各个文件</p>
<p><span class="exturl" data-url="aHR0cDovL2ltYWdlLnN1bjE5OTkudG9wL2Jsb2cvZGF0YS9BbGxDb25maWcuN3o=">AllConfig.7z<i class="fa fa-external-link-alt"></i></span> 如果有遗漏或是下载不了，可以下方留言给，第一时间就会更新~</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hi Hexo!</title>
    <url>/archives/50024.html</url>
    <content><![CDATA[<h1 id="Hi-Hexo"><a href="#Hi-Hexo" class="headerlink" title="Hi Hexo!"></a>Hi Hexo!</h1><p>这是我第一次真正意义上的建站，原来折腾了就删掉了，毕竟自娱自乐，确实懒的维护。这里，希望自己有恒心将本博客一直做下去。</p>
<p>以前，学习笔记一直保存在有道云笔记，云笔记里没有用Markdown，导出也都是 pdf ，没办法放上面，觉得还是原来笔记里的写质量好些=_= </p>
<p>建站的初衷是让自己拥有一个趋近于自由的，可定制化的平台，来记录和分享学习与生活。我也希望相关的技术文章可以让更多人看到，提出批评指正，和大家分享学习过程是一件相当快乐的事，也希望博文可以帮助到大家！</p>
<hr>
<p><strong>GitHub:  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1bm55R3JvY2VyeQ==">SunnyGrocery<i class="fa fa-external-link-alt"></i></span></strong></p>
<p>git上有一些自己简陋的demo，算是记录劳动成果吧，毕竟数据丢失过 ，长记性挂上面了，代码很烂，欢迎吐槽（逃</p>
<ul>
<li><em>Markdown 开始用的着实不顺手，但也感觉到了Markdownd的高效与强大，希望能越来越熟练</em> :)</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计指南</title>
    <url>/archives/1759.html</url>
    <content><![CDATA[<blockquote>
<p>原文章出自<span class="exturl" data-url="aHR0cDovL3d3dy5oYWNrYmFzZS5jb20v">www.hackbase.com<i class="fa fa-external-link-alt"></i></span>，本文对其排版做了部分优化，作者不可考，感谢前人贡献</p>
<p>转自<a href="https://tech.china.com/zh_cn/netschool/programme/167721/20050809/12555491.html"><strong>数据库设计中的14个技巧</strong></a></p>
<p>虽然文章很棒，但年代比较远，关于数据库冗余等的争议性问题，我并不认同文章中的做法，因为现代数据库更注重效率，数据库冗余权衡还是要因地制宜，不可一概而论</p>
</blockquote>
<h3 id="1-原始单据与实体之间的关系"><a href="#1-原始单据与实体之间的关系" class="headerlink" title="1. 原始单据与实体之间的关系"></a>1. 原始单据与实体之间的关系</h3><p>　　可以是一对一、一对多、多对多的关系。在一般情况下，它们是一对一的关系：即一张原始单据对应且只对应一个实体。在特殊情况下，它们可能是一对多或多对一的关系，即一张原始单据对应多个实体，或多张原始单据对应一个实体。这里的实体可以理解为基本表。明确这种对应关系后，对我们设计录入界面大有好处。</p>
<p>　　〖例1〗：一份员工履历资料，在人力资源信息系统中，就对应三个基本表：员工基本情况表、社会关系表、工作简历表。这就是“一张原始单据对应多个实体”的典型例子。</p>
<a id="more"></a>

<h3 id="2-主键与外键"><a href="#2-主键与外键" class="headerlink" title="2. 主键与外键"></a>2. 主键与外键</h3><p>　　一般而言，一个实体不能既无主键又无外键。在E－R 图中, 处于叶子部位的实体, 可以定义主键，也可以不定义主键(因为它无子孙), 但必须要有外键(因为它有父亲)。</p>
<p>　　主键与外键的设计，在全局数据库的设计中，占有重要地位。当全局数据库的设计完成以后，有个美国数据库设计专家说：“键，到处都是键，除了键之外，什么也没有”，这就是他的数据库设计经验之谈，也反映了他对信息系统核心(数据模型)的高度抽象思想。因为：主键是实体的高度抽象，主键与外键的配对，表示实体之间的连接</p>
<h3 id="3-基本表的性质"><a href="#3-基本表的性质" class="headerlink" title="3. 基本表的性质"></a>3. 基本表的性质</h3><p>基本表与中间表、临时表不同，因为它具有如下四个特性：</p>
<ul>
<li>原子性。基本表中的字段是不可再分解的。</li>
<li>原始性。基本表中的记录是原始数据（基础数据）的记录。</li>
<li>演绎性。由基本表与代码表中的数据，可以派生出所有的输出数据。</li>
<li>稳定性。基本表的结构是相对稳定的，表中的记录是要长期保存的。</li>
</ul>
<p>理解基本表的性质后，在设计数据库时，就能将基本表与中间表、临时表区分开来。</p>
<h3 id="4-范式标准"><a href="#4-范式标准" class="headerlink" title="4. 范式标准"></a>4. 范式标准</h3><p>　　基本表及其字段之间的关系, 应尽量满足第三范式。但是，满足第三范式的数据库设计，往往不是最好的设计。为了提高数据库的运行效率，常常需要降低范式标准：适当增加冗余，达到以空间换时间的目的。</p>
<p>　　〖例2〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p>
<p>　　在Rose 2002中，规定列有两种类型：数据列和计算列。“金额”这样的列被称为“计算列”，而“单价”和“数量”这样的列被称为“数据列”。</p>
<p>　　表1.商品表的表结构</p>
<table>
<thead>
<tr>
<th>商品名称</th>
<th>商品型号</th>
<th>单价</th>
<th>数量</th>
<th>金额</th>
</tr>
</thead>
<tbody><tr>
<td>电视</td>
<td>29吋</td>
<td>2,500</td>
<td>40</td>
<td>100,000</td>
</tr>
</tbody></table>
<h3 id="5-通俗地理解三个范式"><a href="#5-通俗地理解三个范式" class="headerlink" title="5. 通俗地理解三个范式"></a>5. 通俗地理解三个范式</h3><p>　　通俗地理解三个范式，对于数据库设计大有好处。在数据库设计中，为了更好地应用三个范式，就必须通俗地理解三个范式(通俗地理解是够用的理解，并不是最科学最准确的理解)：</p>
<p>　　第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；</p>
<p>　　第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；</p>
<p>　　第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p>
<p>　　没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。</p>
<h3 id="6-要善于识别与正确处理多对多的关系"><a href="#6-要善于识别与正确处理多对多的关系" class="headerlink" title="6. 要善于识别与正确处理多对多的关系"></a>6. 要善于识别与正确处理多对多的关系</h3><p>　　若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。</p>
<p>　　〖例3〗：在“图书馆信息系统”中，“图书”是一个实体，“读者”也是一个实体。这两个实体之间的关系，是一个典型的多对多关系：一本图书在不同时间可以被多个读者借阅，一个读者又可以借多本图书。为此，要在二者之间增加第三个实体，该实体取名为“借还书”，它的属性为：借还时间、借还标志(0表示借书，1表示还书)，另外，它还应该有两个外键(“图书”的主键，“读者”的主键)，使它能与“图书”和“读者”连接。  </p>
<h3 id="7-主键PK的取值方法"><a href="#7-主键PK的取值方法" class="headerlink" title="7. 主键PK的取值方法"></a>7. 主键PK的取值方法</h3><p>　　PK是供程序员使用的表间连接工具，可以是一无物理意义的数字串, 由程序自动加1来实现。也可以是有物理意义的字段名或字段名的组合。不过前者比后者好。当PK是字段名的组合时，建议字段的个数不要太多，多了不但索引占用空间大，而且速度也慢。</p>
<h3 id="8-正确认识数据冗余"><a href="#8-正确认识数据冗余" class="headerlink" title="8. 正确认识数据冗余"></a>8. 正确认识数据冗余</h3><p>　　主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚，事实上有许多人还不清楚。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。</p>
<p>　　〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。</p>
<h3 id="9-E－R图没有标准答案"><a href="#9-E－R图没有标准答案" class="headerlink" title="9. E－R图没有标准答案"></a>9. E－R图没有标准答案</h3><p>　　信息系统的E－R图没有标准答案，因为它的设计与画法不是惟一的，只要它覆盖了系统需求的业务范围和功能内容，就是可行的。反之要修改E－R图。尽管它没有惟一的标准答案，并不意味着可以随意设计。好的E－图的标准是：结构清晰、关联简洁、实体个数适中、属性分配合理、没有低级冗余。</p>
<h3 id="10-视图技术在数据库设计中很有用"><a href="#10-视图技术在数据库设计中很有用" class="headerlink" title="10. 视图技术在数据库设计中很有用"></a>10. 视图技术在数据库设计中很有用</h3><p>　　与基本表、代码表、中间表不同，视图是一种虚表，它依赖数据源的实表而存在。视图是供程序员使用数据库的一个窗口，是基表数据综合的一种形式, 是数据处理的一种方法，是用户数据保密的一种手段。为了进行复杂处理、提高运算速度和节省存储空间, 视图的定义深度一般不得超过三层。 若三层视图仍不够用, 则应在视图上定义临时表, 在临时表上再定义视图。这样反复交迭定义, 视图的深度就不受限制了。</p>
<p>　　对于某些与国家政治、经济、技术、军事和安全利益有关的信息系统，视图的作用更加重要。这些系统的基本表完成物理设计之后，立即在基本表上建立第一层视图，这层视图的个数和结构，与基本表的个数和结构是完全相同。并且规定，所有的程序员，一律只准在视图上操作。只有数据库管理员，带着多个人员共同掌握的“安全钥匙”，才能直接在基本表上操作。请读者想想：这是为什么？</p>
<h3 id="11-中间表、报表和临时表"><a href="#11-中间表、报表和临时表" class="headerlink" title="11. 中间表、报表和临时表"></a>11. 中间表、报表和临时表</h3><p>　　中间表是存放统计数据的表，它是为数据仓库、输出报表或查询结果而设计的，有时它没有主键与外键(数据仓库除外)。临时表是程序员个人设计的，存放临时记录，为个人所用。基表和中间表由DBA维护，临时表由程序员自己用程序自动维护。</p>
<h3 id="12-完整性约束表现在三个方面"><a href="#12-完整性约束表现在三个方面" class="headerlink" title="12. 完整性约束表现在三个方面"></a>12. 完整性约束表现在三个方面</h3><p>　　域的完整性：用Check来实现约束，在数据库设计工具中，对字段的取值范围进行定义时，有一个Check按钮，通过它定义字段的值城。</p>
<p>　　参照完整性：用PK、FK、表级触发器来实现。</p>
<p>　　用户定义完整性：它是一些业务规则，用存储过程和触发器来实现。  </p>
<h3 id="13-防止数据库设计打补丁的方法是“三少原则”"><a href="#13-防止数据库设计打补丁的方法是“三少原则”" class="headerlink" title="13. 防止数据库设计打补丁的方法是“三少原则”"></a>13. 防止数据库设计打补丁的方法是“三少原则”</h3><ol>
<li>一个数据库中表的个数越少越好。只有表的个数少了，才能说明系统的E－R图少而精，去掉了重复的多余的实体，形成了对客观世界的高度抽象，进行了系统的数据集成，防止了打补丁式的设计；</li>
<li> 一个表中组合主键的字段个数越少越好。因为主键的作用，一是建主键索引，二是做为子表的外键，所以组合主键的字段个数少了，不仅节省了运行时间，而且节省了索引存储空间；</li>
<li>一个表中的字段个数越少越好。只有字段的个数少了，才能说明在系统中不存在数据重复，且很少有数据冗余，更重要的是督促读者学会“列变行”，这样就防止了将子表中的字段拉入到主表中去，在主表中留下许多空余的字段。所谓“列变行”，就是将主表中的一部分内容拉出去，另外单独建一个子表。这个方法很简单，有的人就是不习惯、不采纳、不执行。</li>
</ol>
<p>　　数据库设计的实用原则是：在数据冗余和处理速度之间找到合适的平衡点。“三少”是一个整体概念，综合观点，不能孤立某一个原则。该原则是相对的，不是绝对的。“三多”原则肯定是错误的。试想：若覆盖系统同样的功能，一百个实体(共一千个属性) 的E－R图，肯定比二百个实体(共二千个属性)的E－R图，要好得多。</p>
<p>　　提倡“三少”原则，是叫读者学会利用数据库设计技术进行系统的数据集成。数据集成的步骤是将文件系统集成为应用数据库，将应用数据库集成为主题数据库，将主题数据库集成为全局综合数据库。集成的程度越高，数据共享性就越强，信息孤岛现象就越少，整个企业信息系统的全局E—R图中实体的个数、主键的个数、属性的个数就会越少。</p>
<p>　　提倡“三少”原则的目的，是防止读者利用打补丁技术，不断地对数据库进行增删改，使企业数据库变成了随意设计数据库表的“垃圾堆”，或数据库表的“大杂院”，最后造成数据库中的基本表、代码表、中间表、临时表杂乱无章，不计其数，导致企事业单位的信息系统无法维护而瘫痪。</p>
<p>　　“三多”原则任何人都可以做到，该原则是“打补丁方法”设计数据库的歪理学说。“三少”原则是少而精的原则，它要求有较高的数据库设计技巧与艺术，不是任何人都能做到的，因为该原则是杜绝用“打补丁方法”设计数据库的理论依据。</p>
<h3 id="14-提高数据库运行效率的办法"><a href="#14-提高数据库运行效率的办法" class="headerlink" title="14. 提高数据库运行效率的办法"></a>14. 提高数据库运行效率的办法</h3><p>在给定的系统硬件和系统软件条件下，提高数据库系统的运行效率的办法是：    </p>
<ol>
<li>在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。</li>
<li>当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。</li>
<li>发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，以该表主键PK的某个值为界线，将该表的记录水平分割为两个表。若发现某个表的字段太多，例如超过八十个，则垂直分割该表，将原来的一个表分解为两个表。</li>
<li>对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。</li>
<li>在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。</li>
</ol>
<hr>
<p>　　<strong>总之，要提高数据库的运行效率，必须从数据库系统级优化、数据库设计级优化、程序实现级优化，这三个层次上同时下功夫</strong>。</p>
<p>　　上述十四个技巧，是许多人在大量的数据库分析与设计实践中，逐步总结出来的。对于这些经验的运用，读者不能生帮硬套，死记硬背，而要消化理解，实事求是，灵活掌握。并逐步做到：在应用中发展，在发展中应用。  </p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title>改为不蒜子统计</title>
    <url>/archives/39388.html</url>
    <content><![CDATA[<blockquote>
<p>​    今天为了让百度更好的收录本站，将一直用的<code>sun1999.top</code>换成了二级域名<code>www.sun1999.top</code></p>
</blockquote>
<h3 id="自闭-ing"><a href="#自闭-ing" class="headerlink" title="自闭 ing"></a>自闭 ing</h3><p>本来一切很顺利，到了最后才发现更改url后原来托管在 leancloud 阅读数统计 失效了。。。倒腾了了半天，还是没有什么办法，只好将统计换为不蒜子，但是这导致了本站原来的统计全部失效==</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年终总结</title>
    <url>/archives/41083.html</url>
    <content><![CDATA[<blockquote>
<p> 说起来一年多没更过blog了，一是懒的写，二是没啥写的。   </p>
</blockquote>
<p>小站本来是为了记些技术笔记，但这一年光学英语高数了，荒废了工程向的东西，自然也没有什么可以记录的。   </p>
<p>本来呢打算考完研总结下考研心路的，奈何考的不咋地，也没啥动力写了。还有就是毕业设计整的我一愣一愣的，题目就换了三个，实在是没精力写了。   </p>
<a id="more"></a>

<hr>
<blockquote>
<p>全文流水账总结：</p>
</blockquote>
<h3 id="找工作——准备and放弃"><a href="#找工作——准备and放弃" class="headerlink" title="找工作——准备and放弃"></a>找工作——准备and放弃</h3><p>当时过完年就打算着手准备面试，当时寒假带回去了些找工作的书：ThinkInJava，剑指offer，算法设计。说来家里人一直想让我考研，我到也一直没明确回应家人是考研还是找工作。   </p>
<p>算是大二学了一年的Java，技术栈也很浅，就是简单的SpringBoot往前的一套，过年那段时间复习了下SpringMVC，然后就开始看剑指offer，越看越枯燥，遂开始摸鱼。怎么说呢，当时疫情在家蹲着，天天看着新闻，总有种<code>百年未有之大变局</code>的感觉，完全，完全学不进去！github上剑指offer的代码最后一次commit是<code>on 13 Jan 2020</code>，现在看了看也没写几个题，现在想想当时还是太浮躁了。   </p>
<hr>
<h3 id="决定考研"><a href="#决定考研" class="headerlink" title="决定考研"></a>决定考研</h3><p>哪天开始准备考研的竟记不清想了想只好去查了下百度网盘是哪天开的（贫穷使我投入网盘盗版课的怀抱orz），</p>
<p><img src="http://image.sun1999.top/20210106195422.png"></p>
<p>没思考几天人生，就做了这个现在看来非常之草率的决定——考研。   </p>
<p>说起做考研这个决定，现在想想有以下的原因</p>
<ol>
<li>逃避，当时呢自己还是个菜狗，也就会写写web项目，算法不能说很差，但也不咋地，不想找个十来万的工作并且加班、加班，再加班；</li>
<li>自己想有个研究生的学历；</li>
<li>B乎里天天吼着程序员怎么怎么地；</li>
<li>准备工作面试属实过于枯燥，怎么说，基本就是越准备面试，越不想工作；</li>
<li>家里人想让我考研，家里人确实一直想让我考研，毕竟本科学历很一般。</li>
</ol>
<p>我知道自己有多懒，既然决定考研，就不打算不给自己留后路了，遂放弃了一切工作向知识的学习，准备安心考研。   </p>
<hr>
<h3 id="准备考研"><a href="#准备考研" class="headerlink" title="准备考研"></a>准备考研</h3><blockquote>
<p>找了找B乎经验帖，对于具体哪个学校也还没想法，就开始准备考研了。</p>
</blockquote>
<ol>
<li>先说英语吧，一生之敌。我准备考研一开始最担心的就是英语，自己英语从小到大没及格过几次。虽然四级一次过了（说起六级的话，我是垃圾），但对英语长期恐惧。随便买了新东方的恋恋有词，看完配套单词视频（我竟然完整看了一遍）。</li>
<li>还有就是数学了，高考全国二卷76分，这成绩基本就是SB，高考考成那样归根到底自己的问题，一直以来数学是不差的，还是没怎么做题的锅。因为基础不咋地，就全跟汤家凤了，有一说一，汤家凤讲的不错。</li>
</ol>
<p>​    一直觉得自己智商不比别人差，只要肯努力，没有什么做不到的。所以开始考研时觉得考研没什么了不起的，无非是学习，学习，再学习，想法很简单：破釜沉舟、背水一战、孤注一掷。</p>
<hr>
<h3 id="考研前期"><a href="#考研前期" class="headerlink" title="考研前期"></a>考研前期</h3><blockquote>
<p>依旧是数学、英语，基本上每天计划就是早上看几个小时的数学课，接着就开始了</p>
</blockquote>
<ol>
<li>英语看完配套视频以后，就开始张剑真题了，我做的是典藏版，那个零几年的版本我也没买，寻思写不完，英语阅读的话，一篇刚开始就是错2-3个，文章经常也是看不懂，搞得我很难受，英语基本也没啥说的，就是一直做阅读，背单词。</li>
<li>数学听完第老汤的视频，算是高数入了门，开始写1800入门+基础，遇到不会的再重听，一开始拿到1800，我还记得极限那一章有好几页的题，看的人脑壳疼，还有就是被证明题教做人 。基本就算是凭一开始的考研的劲头在学数学，丝毫没有学习的乐趣可言。</li>
<li>我专业课开的算是比较早，因为计网本身也是在家学校的网课之一，先跟的韩立刚把谢希仁的第六版看完了。说实话，谢老师的计网教材质量在国内计算机教材里可以说首屈一指，韩老师讲的也真的好，能很好的把理论和实际相结合。</li>
</ol>
<h3 id="考研前中期"><a href="#考研前中期" class="headerlink" title="考研前中期"></a>考研前中期</h3><p>这里我定义我的前中期，大概是高数基础的所有东西都搞定，计网黑书看完一遍，软工开始搞，英语持续的过程改进，政治着手查资料准备开搞。</p>
<p>这个时间基本上已经没有初时的干劲了，只能凭毅力，一天的有效学习时间大概在9-10个小时。其实这个学习时间很少了，因为在家里本来什么都不用做，一天除了学习还有很多的时间玩，在家中克制自己全身心投入并不是一件易事，毕竟我的床就在桌边(￣▽￣)”。</p>
<p>数学开始强化的时候我就有种我基础白学了的感觉，总之让我这种数学底子很差的学数学，真的蛮吃力的，只能说死磕。线代的基础课听的云里雾里。</p>
<blockquote>
<p>整个考研过程中算下来我高数的基础课听了两遍，强化课听了一遍，还有就是各种习题；线代汤家凤基础课一遍，李永乐基础课一遍，强化课两遍，讲义两遍；余炳森基础课两遍，强化课两遍，讲义刷了两遍。</p>
</blockquote>
<p>专业课黑书就是一直看，一直看，到现在我也不知道看了多少遍，，，笔记的话，打印的中国大学MOOC杭电的计网笔记，在此基础上做笔记，还是挺方便的。软工真的不知道从哪里下手学，总觉得说的话怪怪的，看也看不懂，只能去看网课。这里说下成电的软工慕课。虽然念PPT，但是看了还是有些用的，时间充足的话建议一看。专业课资料买了红果研的一套，开始看红果研的软工讲义。一路下来，这么说吧，那辅导讲义+题目基本就是4本垃圾。</p>
<h3 id="考研中后期"><a href="#考研中后期" class="headerlink" title="考研中后期"></a>考研中后期</h3><p>中后期其实是很长的一段时间，期间的学习可以说已经养成了一种学习习惯，没有什么考研的理响做支撑，也已经不觉得一天坐10个多小时受不了了。大致将其分为开学前和开学后把：</p>
<p>开学前：</p>
<p>​    大概就是强化课告一段落，1800写完，660写了100多道题，1000题AB篇写了高数。</p>
<p>开学后：</p>
<p>​    两周时间准备期末考试，期间数学题基本没有断，英语单词没有断，把专业课和政治就断掉了。</p>
<h3 id="考研后期"><a href="#考研后期" class="headerlink" title="考研后期"></a>考研后期</h3><p>很庆幸，我们专业除了补疫情期间的实验，大四上学期只有一节课。开学以后除了考试前的复习课，基本上没有上过几节课，腾给了考研充足的时间。</p>
<p>开学的两周考试周结束基本上就剩100天了。数学开始了李永乐的那本红书真题，这本书是真的不错，而且价格很亲民。计网还是一直在看，软工基本上可以说学了个寂寞，看了半天讲义和没看一样。英语还是阅读单词两件套，实在真题做的没题写了就把张剑预测的阅读全做了，质量出乎意料的感觉还不错。政治呢，基本上到80天的时候徐涛的网课也是看完了，开始1000题。</p>
<p>公寓呢也没有自习室，考研自习室10点20左右关门以后基本上就没有办法学习了，最多最多回去app背个单词，所以中午我也是不回的，一天有效学习时间10个小时多一点。</p>
<h3 id="冲刺"><a href="#冲刺" class="headerlink" title="冲刺"></a>冲刺</h3><p>以50天为界，</p>
<p>数学第二遍李永乐真题快写完了；英语开始作文（除了阅读和作文，其他题型基本上没有练过）；软工看书是没用用的，总结一个字——背；政治第二遍1000题也算是快写完了；</p>
<h3 id="END—上战场"><a href="#END—上战场" class="headerlink" title="END—上战场"></a>END—上战场</h3><p>一年打的装备：</p>
<p>数学：习题：1800（剩概率论强化），660一点点，1000题高数AB，李永乐真题3遍；三门课的讲义过了蛮多遍；模拟卷做了李林6+4(100+)，张宇4(80+)，超越5(100+)，李永乐写了两套没写了。</p>
<p>英语：单词恋恋有词2遍，红宝书2.5遍，百词斩考研核心3.5遍；题的话，就张剑那些了也没什么好说的</p>
<p>政治：徐涛强化刷完，1000题三遍，八套卷一遍选择最低一次36，最高两次43，在肖八和肖四的空挡把腿姐冲刺讲义背了三天，徐涛8套卷做了选择。最后两周四套卷大题每天2小时，选择最低一次40，最高一次43。</p>
<p>专业课：计网黑书看了N遍，课后题复习题过了3遍，习题做了4遍（后两遍都只做自己原来不会的，没有挨着过了）；软工群里<code>张哥</code>开源讲义背了4遍，基本上开始的话两周一遍，后面一周一遍；习题：红果研冲刺卷，A+冲刺卷，<code>张哥</code>开源考研班20年冲刺卷；</p>
<h3 id="FIGHTING"><a href="#FIGHTING" class="headerlink" title="FIGHTING"></a>FIGHTING</h3><p>考研前一天晚上彻夜未眠，22点躺上床，睡前最后一次看表已经是快1点了，3点多自然醒，6点被舍友闹钟吵醒，继续睡到8点起床，吃了个早点冲了杯速溶就上战场了。</p>
<p>坐到座位上怎么说，可能是陕科大我太熟悉了，感觉竟和平时期末考试一样，一点也不紧张，</p>
<p>我们的监考老师特别唠叨，政治开考5分钟了还在念考场规章，以至于下午英语考试我给老师发脾气了，记忆犹新-——“你能少说两句吧，你好吵啊！”，就这么喊了出来。</p>
<p>初试成绩还没有出来，大概的战况：</p>
<blockquote>
<p>政治：肖秀荣牛逼；</p>
<p>英语：题很难，考的一般，时间没有分配好，考的很一般，没有达到预期；</p>
<p>数学：题很简单，我很垃圾。怎么说呢，考数学时心里很乱，很紧张，看到选择题感觉跟看到天书一样，大题做完回过头看选择有感觉不难了，一来一回浪费了很多的时间，大题正确率也没有保障了。总的来说这此数学可以说考的一塌糊涂，能考到预期90分的话，我很满足。</p>
<p>专业课：860还真的是一切皆有可能，计网竟然考了子网划分和DV，我原来觉得这是万万不可能考的，不过考的也很简单，总体满意。</p>
</blockquote>
<p>预估这次初试如果成绩运气好可以过复试线，但是过不了太多，绝对在平均分往下。无比希望能过初试线，也好对自己这一年的付出有个交代。</p>
<p align='right'>2021/01/13 中午</p>

]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>失眠杂谈</title>
    <url>/archives/58799.html</url>
    <content><![CDATA[<blockquote>
<p>五味杂陈，说来已为人19朝，至今不知人生来为何?</p>
</blockquote>
<p>周末总是起的晚，我在所难免的又一次失眠了，当然各种的鼾声也是元凶之一，听着舍友说梦话也是很惬意的事。说来有趣，失眠之时，眼前如同好莱坞，支离片段，陈年旧事，都如电影一般，涌上心头，还不如下床记录下内心活动</p>
<p>要知道，记录下自己的胡思乱想是一件多么困难的事，但还是试试吧。自己语言功底我还是有数的，读的书屈指可数，说话还爱爆粗口，我这出去之后别人一看，估计当是哪个高中没毕业的。。。就这样吧，深夜随便码些字，图个快乐，排解下烦恼吧~</p>
<a id="more"></a>

<hr>
<h3 id="我为谁而奋斗？"><a href="#我为谁而奋斗？" class="headerlink" title="我为谁而奋斗？"></a>我为谁而奋斗？</h3><p><em>不忘初心这句话一直在耳边回荡，一直认为，人生的所有努力，都是为了自己与他人快乐</em></p>
<ol>
<li><p>我想要环游世界（不得不说，这也许是我最大的愿望了）</p>
<ol>
<li><p>没钱 ；钱不能边旅游边挣，背包客不好吗，多帅o？</p>
</li>
<li><p>工地英语 ；还有工地英语交流不够用吗？</p>
</li>
<li><p>还有学业要完成 ；休学不行吗？你男神李志上东大也都退学做音乐，追求自我去了，你怂个鸡儿？</p>
</li>
</ol>
</li>
<li><p>我想要挣钱</p>
<ol>
<li>菜；菜还不好好学啊？</li>
<li>没能力；还不是菜！</li>
<li>嫌挣钱累；谁挣钱不累啊，你当人家的钱飘来的？</li>
</ol>
</li>
<li><p>我想找到自己心爱的姑娘</p>
<ol>
<li>肥宅快乐，是游戏不好玩吗；真的肥宅快乐吗？健身，图书馆不好吗！</li>
<li>没时间；没时间？少睡会懒觉，少打会守望，少看会直播，什么时间挤不出来？</li>
<li>毕竟立过自己现在觉得可笑的flag，还是遵守下吧；flag？骗鬼吧，逃避的幌子，胆小鬼~</li>
</ol>
</li>
<li><p>我想敲出最优美的代码，贡献给所有需要的人</p>
<ol>
<li>基础就很差；完蛋吧，大一一天就王者农药了，这不中毒了</li>
<li>水平这么LJ，有什么可贡献的；这个，确实垃圾，不知道怎么骂=.=</li>
<li>学习方法导致的学习效率低下；你难道真的不知道最快的学习方法是动手敲？看能看懂，就是懒怂！</li>
</ol>
</li>
</ol>
<p><strong>我到底想要什么？</strong></p>
<blockquote>
<p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p>
<p>​                                                                                                                ——王小波《黄金时代》</p>
</blockquote>
<p>文章的人生观大概小波也都概括的差不多。生活就是个缓慢受锤的过程，所想与所得总是千差万别</p>
<p>这里想到了伊瑟拉的台词：当我入梦，这个世界就将颤抖<br>细细品味还是蛮有趣，有意识的梦境中，自己便是伸手可摘月的神</p>
<hr>
<h3 id="握不住的是时光，迷茫的仍是我这个铁憨憨"><a href="#握不住的是时光，迷茫的仍是我这个铁憨憨" class="headerlink" title="握不住的是时光，迷茫的仍是我这个铁憨憨"></a>握不住的是时光，迷茫的仍是我这个铁憨憨</h3><ul>
<li>高中很迷茫，不知道自己想要什么，只听家人在耳边疯狂安利考大学，结果也考的不怎么样，毕竟当时觉得不是自己想要的东西</li>
</ul>
<hr>
<ul>
<li><p>大一？更迷茫。人们都说大学奇葩多，我刚开始还不信。</p>
</li>
<li><p>几个月之后，我就能感觉到周围的人和高中差别很大很大，就不是世界观人生观了，起码的价值观就相差很大，性格也有许多的不同。这也导致了刚来大学人际关系处理的比较糟糕。</p>
</li>
<li><p>我算是深刻体会知道了环境对人的影响有多大，环境真真切切的塑造了每一个人的价值观念与性格，细思极恐的东西，当然这大概就是世界的多元之美吧</p>
<blockquote>
<p>你说你遇见了一大堆奇怪的人<br>他们看上去好像都比你开心<br>你能不能抽空替我去一个地方<br>据说那的人都擅长给别人答案</p>
<p>——李志《定西》</p>
</blockquote>
</li>
<li><p>李志的专访看过好几部，他说他是荔枝，表面坚硬，实则果肉鲜嫩，但是核很硬。我也觉得自己算是这样一类人。</p>
</li>
<li><p>学习上吧 ，我也不知道咋想的，有点杞人忧天的大一就开始担心就业，学了好多杂七杂八的东西，现在想起来，又可笑又无奈，毕竟这就是成长的过程，弯路走的比较多，但还算行吧，至少没有虚度光阴</p>
</li>
</ul>
<hr>
<ul>
<li><p>一年时间很快，大二算是很自然的转了专业，有幸遇见了如此有活力的一群人，并肩前行总是快乐，毕竟压力什么的有人排解会好很多。半年时间，没有浪费，回想起来，很感谢那段时光。</p>
<blockquote>
<p>这里<code>@某人</code>：那段时间所谓的抑郁症与不开心，现在也都过去了吧，前进的路上愿你不再被这种魔鬼所束缚，相信未来，莫愁前路无知己，天下谁人不识君？不在一所学校，我也算是一个不太喜欢在线聊天的人，不喜欢一天这那的多BB，遇到合适的战友，一起奋斗吧！</p>
</blockquote>
</li>
<li><p>大二一年，也算接近了尾声。说实话，不知道学了什么，这大概是我对教学安排最不满的一年，话不多说，啥时候要开始从头学下模电什么的，真的烦，</p>
</li>
<li><p>如今认为自己的努力不是自己想要的，甚至觉得大学，都不是自己想要的，我也想像李志一样，大学肆业，去追逐梦想，但我没有勇气</p>
</li>
<li><p>接收教育？希望会好吧</p>
<blockquote>
<p>Education,Education——出路</p>
<p>教育这条出路，不仅是一个家庭的出路，更是一个社会的出路。甚至它就不该是家庭的出路。</p>
<p>大学不是必须的，他还是应该保持一定的门槛，对于对它有真正需求的人，我们需要让他们短暂的离开一下地面。我们要教他们正义、善良和美。</p>
<p>但是我们怎么才能保证那些没上大学的人也能受到良好的教育，有个良好的出路呢？</p>
<p>我们什么时候才能接受“工作不是仅仅为了养家糊口，还能够自我实现和自我满足，所以我们要透彻的指导自己合适什么、要什么和喜欢什么再进行选择”这种概念呢？</p>
<p>我不知道，活在当下的自己，还是好好想想自己要怎么对待大学这剩下的三年零几个月吧。第一步，面对问题不要麻木。  </p>
<p>作者：🍬Petaloúda </p>
<p>原文连接：<code>https://movie.douban.com/review/5824887/</code></p>
</blockquote>
<p>这是一篇剧评，文章应该写是在作者大一之时，思考人生，是真的累，看过片子可能更有感触。</p>
<p>我自认为自己戴着一个面具，请放心，不是般若，只是恰当的伪装罢了。但谁又不是呢，有谁在大众面前不压抑自己的内心想法，我也一直努力摘下面具，希望将自己最真实的一面展现给他人，正如此文章，分享下自己的想法云云。</p>
<p>多多独立思考，大学给我们这样一个轻松，独立与相对自由的环境，珍惜她，不要荒废，希望每个人都能找到自己-想要的东西，为之努力，相信这个世界会更好！</p>
</li>
</ul>
<hr>
<p>  ​                                                                                                                                       5.26. 深夜 愿世界温柔以待</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Difference between / and /* in servlet mapping url pattern</title>
    <url>/archives/23740.html</url>
    <content><![CDATA[<h3 id="lt-url-pattern-gt-lt-url-pattern-gt"><a href="#lt-url-pattern-gt-lt-url-pattern-gt" class="headerlink" title="&lt;url-pattern&gt;/*&lt;/url-pattern&gt;"></a><code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code></h3><p>The <code>/*</code> on a servlet overrides all other servlets, including all servlets provided by the servletcontainer such as the default servlet and the JSP servlet. Whatever request you fire, it will end up in that servlet. This is thus a bad URL pattern for servlets. Usually, you’d like to use <code>/*</code> on a <a href="http://download.oracle.com/javaee/6/api/javax/servlet/Filter.html"><code>Filter</code></a> only. It is able to let the request continue to any of the servlets listening on a more specific URL pattern by calling [<code>FilterChain#doFilter()</code>](<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YWVlLzYvYXBpL2phdmF4L3NlcnZsZXQvRmlsdGVyQ2hhaW4uaHRtbCNkb0ZpbHRlcg==">http://download.oracle.com/javaee/6/api/javax/servlet/FilterChain.html#doFilter<i class="fa fa-external-link-alt"></i></span>(javax.servlet.ServletRequest, javax.servlet.ServletResponse)).</p>
<a id="more"></a>

<h3 id="lt-url-pattern-gt-lt-url-pattern-gt-1"><a href="#lt-url-pattern-gt-lt-url-pattern-gt-1" class="headerlink" title="&lt;url-pattern&gt;/&lt;/url-pattern&gt;"></a><code>&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code></h3><p>The <code>/</code> doesn’t override any other servlet. It only replaces the servletcontainer’s builtin default servlet for all requests which doesn’t match any other registered servlet. This is normally only invoked on static resources (CSS/JS/image/etc) and directory listings. The servletcontainer’s builtin default servlet is also capable of dealing with HTTP cache requests, media (audio/video) streaming and file download resumes. </p>
<p>Usually, you don’t want to override the default servlet as you would otherwise have to take care of all its tasks, which is not exactly trivial (JSF utility library <span class="exturl" data-url="aHR0cDovL29tbmlmYWNlcy5vcmcv">OmniFaces<i class="fa fa-external-link-alt"></i></span> has an <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29tbmlmYWNlcy9vbW5pZmFjZXMvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9vcmcvb21uaWZhY2VzL3NlcnZsZXQvRmlsZVNlcnZsZXQuamF2YQ==">open source<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3Nob3djYXNlLm9tbmlmYWNlcy5vcmcvc2VydmxldHMvRmlsZVNlcnZsZXQ=">example<i class="fa fa-external-link-alt"></i></span>). </p>
<blockquote>
<p>译：通常，你并不希望覆盖默认的servlet，因为这样您必须处理它的所有任务，这并不容易(JSF实用程序库OmniFaces有一个开源示例)。</p>
<p>注：SpringMVC就是要接管所有任务，所以要我们要覆盖容器默认的servlet，静态文件配置<code>&lt;mvc:default-servlet-handler/&gt;</code>即可排除</p>
</blockquote>
<p>This is thus also a bad URL pattern for servlets. As to why JSP pages doesn’t hit this servlet, it’s because the servletcontainer’s builtin JSP servlet will be invoked, which is already by default mapped on the more specific URL pattern <code>*.jsp</code>.</p>
<h3 id="lt-url-pattern-gt-lt-url-pattern-gt-2"><a href="#lt-url-pattern-gt-lt-url-pattern-gt-2" class="headerlink" title="&lt;url-pattern&gt;&lt;/url-pattern&gt;"></a><code>&lt;url-pattern&gt;&lt;/url-pattern&gt;</code></h3><p>Then there’s also the empty string URL pattern . This will be invoked when the context root is requested. This is different from the <a href="https://stackoverflow.com/questions/14648167/how-to-configure-welcome-file-list-in-web-xml/"><code>&lt;welcome-file&gt;</code></a> approach that it isn’t invoked when any subfolder is requested. This is most likely the URL pattern you’re actually looking for in case you want a “<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzMyNDg0NzMvY2hhbmdlLWRlZmF1bHQtaG9tZXBhZ2UtaW4tcm9vdC1wYXRoLXRvLXNlcnZsZXQtd2l0aC1kb2dldC8=">home page servlet<i class="fa fa-external-link-alt"></i></span>“. I only have to admit that I’d intuitively expect the empty string URL pattern <code> </code> and the slash URL pattern <code>/</code> be defined exactly the other way round, so I can understand that a lot of starters got confused on this. But it is what it is.</p>
<h3 id="Front-Controller"><a href="#Front-Controller" class="headerlink" title="Front Controller"></a>Front Controller</h3><p>In case you <em>actually</em> intend to have a front controller servlet, then you’d best map it on a more specific URL pattern like <code>*.html</code>, <code>*.do</code>, <code>/pages/*</code>, <code>/app/*</code>, etc. You can hide away the front controller URL pattern and cover static resources on a common URL pattern like <code>/resources/*</code>, <code>/static/*</code>, etc with help of a servlet filter. See also <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM1MjE5NDYvaG93LXRvLXByZXZlbnQtc3RhdGljLXJlc291cmNlcy1mcm9tLWJlaW5nLWhhbmRsZWQtYnktZnJvbnQtY29udHJvbGxlci1zZXJ2bGV0LXc=">How to prevent static resources from being handled by front controller servlet which is mapped on /*<i class="fa fa-external-link-alt"></i></span>. Noted should be that Spring MVC has a builtin static resource servlet, so that’s why you could map its front controller on <code>/</code> if you configure a common URL pattern for static resources in Spring. See also <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ4MzA2My9zcHJpbmctbXZjLTMtYW5kLWhhbmRsaW5nLXN0YXRpYy1jb250ZW50LWFtLWktbWlzc2luZy1zb21ldGhpbmc=">How to handle static content in Spring MVC?<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>作者：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xNTc4ODIvYmFsdXNj">BalusC<i class="fa fa-external-link-alt"></i></span></p>
<p>文章转载自：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDE0MDQ0OC9kaWZmZXJlbmNlLWJldHdlZW4tYW5kLWluLXNlcnZsZXQtbWFwcGluZy11cmwtcGF0dGVybg==">Difference between / and /* in servlet mapping url pattern<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP中GET与POST的区别</title>
    <url>/archives/54536.html</url>
    <content><![CDATA[<p>GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。</p>
<p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p>
<p>你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。</p>
<p>当你在面试中被问到这个问题，你的内心充满了自信和喜悦。</p>
<a id="more"></a>

<p><img src="http://image.sun1999.top/20190531174323.png"></p>
<p>你轻轻松松的给出了一个“标准答案”：</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
</ul>
<ul>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
</ul>
<ul>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
</ul>
<ul>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
</ul>
<ul>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
</ul>
<ul>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
</ul>
<ul>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
</ul>
<ul>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
</ul>
<ul>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<p>（本标准答案参考自w3schools）</p>
<p>“很遗憾，这不是我们要的回答！”</p>
<p><img src="http://image.sun1999.top/20190531174408.png"></p>
<p>请告诉我真相。。。</p>
<p>如果我告诉你GET和POST本质上没有区别你信吗？ </p>
<p>让我们扒下GET和POST的外衣，坦诚相见吧！</p>
<p><img src="http://image.sun1999.top/20190531174424.png"></p>
<p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 </p>
<p>那么，“标准答案”里的那些区别是怎么回事？</p>
<p><img src="http://image.sun1999.top/20190531174450.png"></p>
<p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p>
<p>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p>
<p><img src="http://image.sun1999.top/20190531174520.png"></p>
<p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
<p>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 </p>
<p>你以为本文就这么结束了？</p>
<p><img src="http://image.sun1999.top/20190531174540.png"></p>
<p>我们的大BOSS还等着出场呢。。。</p>
<p>这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。</p>
<p>GET和POST还有一个重大区别，简单的说：</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>长的说：</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>
<ol>
<li><p>GET与POST都有自己的语义，不能随便混用。</p>
</li>
<li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p>
</li>
<li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>
</li>
</ol>
<p>现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？</p>
<p><img src="http://image.sun1999.top/20190531174554.png"></p>
<p>（本文原创，转载请注明转自微信公众号WebTechGarden）</p>
<p>（如文中有纰漏，请不吝更正）</p>
<blockquote>
<p>文章转载自：微信公众号WebTechGarden</p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>简易的RESTfulAPI设计指南</title>
    <url>/archives/24834.html</url>
    <content><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9odHRwL2h0dHAtaW50cm8uaHRtbA==">菜鸟教程—HTTP简介<i class="fa fa-external-link-alt"></i></span> 比本文写的好+.+</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL:"></a>URL:</h3><p>格式：<code>schema://host[:post]/path[?query-string][#anchor]</code></p>
<ul>
<li>schema   指定底层使用的协议（例如：http,https,ftp…）</li>
<li>host   服务器的IP地址或者域名</li>
<li>port   服务器端口，http默认80,https默认443</li>
<li>path 资源访问的路径</li>
<li>query-string 发送给http服务器的数据</li>
<li>anchor 锚，当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。   </li>
</ul>
<a id="more"></a>

<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>格式：请求行、消息报头、请求正文</p>
<ul>
<li><p>请求行：Method Request-URI HTTP-Version CRLF (请求方法 请求地址 请求所使用的HTTP版本号（v1.0、v1.1）回车换行)</p>
<p>eg. GET/HTTP/1.1</p>
</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>格式：状态行、消息报头、响应正文</p>
<ul>
<li><p>状态行：HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>eg. HTTP/1.1 200 OK</p>
<p>常用状态码：</p>
<ul>
<li>200 OK //客户端请求成功</li>
<li>400 Bad Request //客户端请求有语法错误，服务器无法理解</li>
<li>401 Unauthorized //服务器收到请求，但拒绝服务</li>
<li>404 Not Found //服务器无法根据客户端的请求找到资源</li>
<li>500 Internal Server Error //服务器内部错误，即有bug啊</li>
<li>503 Service Unavailable //由于超载或系统维护，服务器暂时的无法处理客户端的请求。</li>
</ul>
</li>
</ul>
<h2 id="设计RESTful-API"><a href="#设计RESTful-API" class="headerlink" title="设计RESTful API"></a>设计RESTful API</h2><h3 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h3><p>在RESTful架构中，每个网址代表一种资源，所以网址中不能有动词，只能有名词。</p>
<p>一般来说API的名词应该使用复数</p>
<p>举例：</p>
<p>举例来说，有一个API提供动物园的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样：</p>
<ul>
<li><p>动物园资源:<code>https://api.example.com/vi/zoos</code> ，版本号也可以放在请求头中</p>
</li>
<li><p>动物资源:<code>https://api.example.com/vi/animals</code></p>
</li>
<li><p>雇员资源:<code>https://api.example.com/vi/employees</code></p>
</li>
</ul>
<h3 id="请求Method"><a href="#请求Method" class="headerlink" title="请求Method"></a>请求Method</h3><ul>
<li>POST/zoos:新建一个动物园</li>
<li>GET/zoos/ID：获取某个指定动物园的信息</li>
<li>PUT/zoos/ID：更新某个指定动物园的信息</li>
<li>DELETE/zoos/ID：删除某个动物园</li>
</ul>
<h3 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h3><p>如果记录数量很多，服务器不可能都将他们返回给客户，API应该提供参数，过滤返回结果（分页）</p>
<p>举例：</p>
<ul>
<li>?offset=10：指定返回记录的开始位置</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数</li>
<li>?sortby=name&amp;order=asc：指定返回结果序列，以及排序顺序</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li><p>200 OK 服务器成功返回用户请求的数据，该操作是幂等的</p>
</li>
<li><p>201 CREATED 新建或修改数据成功</p>
</li>
<li><p>204 NO CONTENT 删除数据成功//删除数据时是没有响应体的</p>
</li>
<li><p>400 BAD REQUEST 用户发出的请求有错误，该操作幂等</p>
</li>
<li><p>401 Unauthorized 表示该用户没有认证，不能执行当前操作   //没有提供认证参数</p>
</li>
<li><p>403 Forbidden 表示用户权限不足，无权执行当前操作   //提供了认证参数，但还是被拒绝</p>
</li>
<li><p>422 Unprocesable Entity 创建/更新对象时，发生数据验证错误 ，配合响应体返回相应信息</p>
</li>
<li><p>500 Internal Server Error 服务器内部错误，无法完成请求</p>
</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果状态码是4xx或者5xx，就应该向用户返回出错信息。一般返回信息中将”error“作为key，出错信息作为value(为了安全，不要将具体的服务器错误调用栈返回出去)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="attr">&quot;error&quot;</span> : <span class="string">&quot;参数错误&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范：</p>
<ul>
<li><p>GET/collections：返回资源对象的列表（数组）</p>
</li>
<li><p>GET/collections/identity：返回单个资源对象</p>
</li>
<li><p>POST/collections/identity：返回新生成的资源对象</p>
</li>
<li><p>PUT/collections/identity：返回更新后的完整的资源对象</p>
</li>
<li><p>PATCH/collections/identity：返回资源被修改的属性</p>
</li>
<li><p>DELETE/collections/identity：返回204状态码和一个空的响应体</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA使用指南-1</title>
    <url>/archives/8182.html</url>
    <content><![CDATA[<p>本文采用Hibernate 3.2+作为JPA的实现方法，脱离常用的框架对 JPA 的 API 进行测试使用</p>
<blockquote>
<p>Java Persistence API：用于对象持久化的 API<br>Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层</p>
<p>目前Hibernate 3.2+、TopLink 10.1+ 以及 OpenJPA 都提供了 JPA 的实现</p>
</blockquote>
<a id="more"></a>

<h2 id="测试项目的目录结构"><a href="#测试项目的目录结构" class="headerlink" title="测试项目的目录结构"></a>测试项目的目录结构</h2><p><img src="http://image.sun1999.top/20190822205229.png"></p>
<h2 id="文件罗列"><a href="#文件罗列" class="headerlink" title="文件罗列"></a>文件罗列</h2><h3 id="JPA配置文件"><a href="#JPA配置文件" class="headerlink" title="JPA配置文件"></a>JPA配置文件</h3><blockquote>
<p>classpath:META-INF/persistence.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/persistence</span></span></span><br><span class="line"><span class="tag"><span class="string">             http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置持久化单元（可以配置多个，名称不能重复）W</span></span><br><span class="line"><span class="comment">        name:用于指定持久化单元的名称</span></span><br><span class="line"><span class="comment">        transcation-type:指定事务的类型。</span></span><br><span class="line"><span class="comment">        JTA:Java Transcation API</span></span><br><span class="line"><span class="comment">        RESOURCE_LOCAL:指的是本地代码事务</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;myPersistenceUnit-1&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--JPA规范提供商，可以不写--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定Jpa注解的实体类型位置，可以不写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sust.entity.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--连接相关的一些配置，都是用hibernate的。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--第一部分，连接数据库信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://192.168.0.113:3306/jpa?characterEncoding=utf8<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;89321&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--说明:数据库的方言，用于存放不同数据库之间的SQL语句差异。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hibernate.dialect.MySQL8Dialect&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--第二部分，hibernate的可选配置--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否显示hiberante的生成的SQL语句--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否使用格式化输出SQL语句到控制台--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--采用何种方式生成DDL语句，update表示检测实体类的映射配置与数据库表结构是否一致，不一致，则更新数据库。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--连接池的配置，这里使用的是c3p0连接池，常用的还有druid--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            &lt;property name=&quot;hibernate.connection.provider_class&quot;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--                      value=&quot;org.hibernate.c3p0.internal.C3P0ConnectionProvider&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实体类配置"><a href="#实体类配置" class="headerlink" title="实体类配置"></a>实体类配置</h3><blockquote>
<p> Customer.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sust.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.CreationTimestamp;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.DynamicInsert;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.DynamicUpdate;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.UpdateTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_customers&quot;)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *动态插入和删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="meta">@DynamicInsert</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @GeneratedValue(strategy = GenerationType.XXX)</span></span><br><span class="line"><span class="comment">     * 1.IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</span></span><br><span class="line"><span class="comment">     * 2.AUTO： JPA自动选择合适的策略，是默认选项；</span></span><br><span class="line"><span class="comment">     * 3.SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</span></span><br><span class="line"><span class="comment">     * 4.TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</span></span><br><span class="line"><span class="comment">     *     若 @GeneratedValue 中 strategy = GenerationType.TABLE ，</span></span><br><span class="line"><span class="comment">     *     就还要配置 generator属性与 @TableGenerator注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;CustomerPKGenerated&quot;)</span></span><br><span class="line">    <span class="meta">@TableGenerator(</span></span><br><span class="line"><span class="meta">            name = &quot;CustomerPKGenerated&quot;, // 与GeneratedValue中generator属性相同即可</span></span><br><span class="line"><span class="meta">            table = &quot;auto_increment_table&quot;, // 增长辅助表表名</span></span><br><span class="line"><span class="meta">            pkColumnName = &quot;PK_NAME&quot;, // 主键列</span></span><br><span class="line"><span class="meta">            pkColumnValue = &quot;customer_id&quot;,// 主键列中代表此表主键的字段值</span></span><br><span class="line"><span class="meta">            valueColumnName = &quot;PK_VALUE&quot;, //value种子的列名</span></span><br><span class="line"><span class="meta">            allocationSize = 5 //每次增长数</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Basic 表示一个简单的属性到数据库表的字段的映射,</span></span><br><span class="line"><span class="comment">     * 对于没有任何标注的 getXxxx() 方法,默认即为@Basic,即普通字段可以省略</span></span><br><span class="line"><span class="comment">     *      1.fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,</span></span><br><span class="line"><span class="comment">     *				分别表示主支抓取和延迟加载,默认为 EAGER.</span></span><br><span class="line"><span class="comment">     *      2.optional:表示该属性是否允许为null, 默认为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Basic(fetch = FetchType.EAGER, optional = true)</span><span class="comment">//这里都用了默认值</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当实体的属性与其映射的数据库表的列不同名时需要使用@Column 标注说明</span></span><br><span class="line"><span class="comment">     * 该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用,</span></span><br><span class="line"><span class="comment">     *		@Column标注也可置于属性的getter方法之前</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.name属性：用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，</span></span><br><span class="line"><span class="comment">     *		如：unique 、nullable、length 等。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2.columnDefinition 属性: 表示该字段在数据库中的实际类型.</span></span><br><span class="line"><span class="comment">     *		通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型</span></span><br><span class="line"><span class="comment">     *		如将Integet类型变量的数据库类型指定为TINYINT：</span></span><br><span class="line"><span class="comment">     *			@Column(columnDefinition = &quot;TINYINT&quot;)</span></span><br><span class="line"><span class="comment">     *      但此属性对于Date类型，仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.</span></span><br><span class="line"><span class="comment">     *			处理需要用到@Temporal(TemporalType.XXX)来指定具体类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;last_name&quot;, nullable = false)</span><span class="comment">//JPA生成表时不会自动转换驼峰命名</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Column(length = 100, columnDefinition = &quot;TINYINT&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------*/</span></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="meta">@Temporal(TemporalType.TIMESTAMP)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;create_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="meta">@Temporal(TemporalType.TIMESTAMP)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;update_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Temporal(TemporalType.DATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="CustomerRepo-java"><a href="#CustomerRepo-java" class="headerlink" title="CustomerRepo.java"></a>CustomerRepo.java</h3><blockquote>
<p>这里并没有实现CURD操作，只是以插入数据的方式来展示流程，测试配置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sust.repo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sust.entity.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityTransaction;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRepo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建 EntityManagerFactory</span></span><br><span class="line">        String persistenceUnitName = <span class="string">&quot;myPersistenceUnit-1&quot;</span>;</span><br><span class="line">        EntityManagerFactory entityManagerFactory =</span><br><span class="line">            Persistence.createEntityManagerFactory(persistenceUnitName);</span><br><span class="line">        <span class="comment">//2.创建 EntityManager 对象</span></span><br><span class="line">        EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line">        <span class="comment">//3.开启事务</span></span><br><span class="line">        EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="comment">//4.执行持久化操作</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.setLastName(<span class="string">&quot;Test_1&quot;</span>);</span><br><span class="line">        customer.setEmail(<span class="string">&quot;999@sust.edu.cn&quot;</span>);</span><br><span class="line">        customer.setAge(<span class="number">66</span>);</span><br><span class="line">        entityManager.persist(customer);</span><br><span class="line">        <span class="comment">//5.提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        <span class="comment">//6.关闭 EntityManager 与 EntityManagerFactory</span></span><br><span class="line">        entityManager.close();</span><br><span class="line">        entityManagerFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="POM-xml"><a href="#POM-xml" class="headerlink" title="POM.xml"></a>POM.xml</h3><blockquote>
<p>项目依赖jar</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.10.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-jpa-2.1-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="运行前状态："><a href="#运行前状态：" class="headerlink" title="运行前状态："></a>运行前状态：</h3><ul>
<li>数据库结构：</li>
</ul>
<p>​    <img src="http://image.sun1999.top/20190822211229.png"></p>
<ul>
<li><p>自增辅助表(auto_increment_table)DDL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `auto_increment_table` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `PK_NAME` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `PK_VALUE` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure></li>
<li><p><code>auto_increment_table</code>表数据：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>PK_NAME</th>
<th>PK_VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>customer_id</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="运行5次-new-CustomerRepo-test-后："><a href="#运行5次-new-CustomerRepo-test-后：" class="headerlink" title="运行5次 new CustomerRepo().test()后："></a>运行5次 <code>new CustomerRepo().test()</code>后：</h3><ul>
<li>数据库结构：</li>
</ul>
<p><img src="http://image.sun1999.top/1566480222214.png"></p>
<ul>
<li><p><code>auto_increment_table</code>更新为</p>
<blockquote>
<p>没有搞懂PK_VALUE的增长策略</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>PK_NAME</th>
<th>PK_VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>customer_id</td>
<td>31</td>
</tr>
</tbody></table>
<ul>
<li><p>自动创建的数据表(jpa_customers)DDL:（注意主键并没有自增属性）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `jpa_customers` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,<span class="operator">/</span><span class="operator">/</span>注意这里的tinyint</span><br><span class="line">  `birthday` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,<span class="operator">/</span><span class="operator">/</span>注意这里的<span class="type">date</span></span><br><span class="line">  `create_time` datetime(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure></li>
<li><p><code>jpa_customers</code>数据：</p>
<blockquote>
<p><code>jpa_customers</code>表中的主键也并不是像<code>@TableGenerator</code>注解中<code>allocationSize=5</code>属性配置的每次都增长5，而是第一次增长6，以后才是5。。。很奇怪</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
<th>birthday</th>
<th>create_time</th>
<th>email</th>
<th>last_name</th>
<th>update_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>66</td>
<td>2019-08-22</td>
<td>2019-08-23 05:39:01</td>
<td><span class="exturl" data-url="bWFpbHRvOiYjeDM5OyYjNTc7JiN4Mzk7JiN4NDA7JiMxMTU7JiN4NzU7JiN4NzM7JiMxMTY7JiM0NjsmI3g2NTsmIzEwMDsmIzExNzsmI3gyZTsmI3g2MzsmIzExMDs=">&#x39;&#57;&#x39;&#x40;&#115;&#x75;&#x73;&#116;&#46;&#x65;&#100;&#117;&#x2e;&#x63;&#110;<i class="fa fa-external-link-alt"></i></span></td>
<td>Test_1</td>
<td>2019-08-23 05:39:01</td>
</tr>
<tr>
<td>7</td>
<td>66</td>
<td>2019-08-22</td>
<td>2019-08-23 05:39:02</td>
<td><span class="exturl" data-url="bWFpbHRvOiYjeDM5OyYjeDM5OyYjeDM5OyYjNjQ7JiMxMTU7JiMxMTc7JiMxMTU7JiN4NzQ7JiN4MmU7JiMxMDE7JiMxMDA7JiN4NzU7JiN4MmU7JiN4NjM7JiMxMTA7">&#x39;&#x39;&#x39;&#64;&#115;&#117;&#115;&#x74;&#x2e;&#101;&#100;&#x75;&#x2e;&#x63;&#110;<i class="fa fa-external-link-alt"></i></span></td>
<td>Test_1</td>
<td>2019-08-23 05:39:02</td>
</tr>
<tr>
<td>12</td>
<td>66</td>
<td>2019-08-22</td>
<td>2019-08-23 05:39:02</td>
<td><span class="exturl" data-url="bWFpbHRvOiYjeDM5OyYjeDM5OyYjNTc7JiN4NDA7JiN4NzM7JiN4NzU7JiMxMTU7JiN4NzQ7JiN4MmU7JiN4NjU7JiMxMDA7JiMxMTc7JiN4MmU7JiN4NjM7JiN4NmU7">&#x39;&#x39;&#57;&#x40;&#x73;&#x75;&#115;&#x74;&#x2e;&#x65;&#100;&#117;&#x2e;&#x63;&#x6e;<i class="fa fa-external-link-alt"></i></span></td>
<td>Test_1</td>
<td>2019-08-23 05:39:02</td>
</tr>
<tr>
<td>17</td>
<td>66</td>
<td>2019-08-22</td>
<td>2019-08-23 05:39:02</td>
<td><span class="exturl" data-url="bWFpbHRvOiYjNTc7JiM1NzsmIzU3OyYjeDQwOyYjeDczOyYjMTE3OyYjeDczOyYjeDc0OyYjNDY7JiN4NjU7JiN4NjQ7JiMxMTc7JiN4MmU7JiM5OTsmIzExMDs=">&#57;&#57;&#57;&#x40;&#x73;&#117;&#x73;&#x74;&#46;&#x65;&#x64;&#117;&#x2e;&#99;&#110;<i class="fa fa-external-link-alt"></i></span></td>
<td>Test_1</td>
<td>2019-08-23 05:39:02</td>
</tr>
<tr>
<td>22</td>
<td>66</td>
<td>2019-08-22</td>
<td>2019-08-23 05:39:02</td>
<td><span class="exturl" data-url="bWFpbHRvOiYjNTc7JiN4Mzk7JiM1NzsmI3g0MDsmIzExNTsmIzExNzsmIzExNTsmI3g3NDsmIzQ2OyYjeDY1OyYjMTAwOyYjMTE3OyYjeDJlOyYjOTk7JiN4NmU7">&#57;&#x39;&#57;&#x40;&#115;&#117;&#115;&#x74;&#46;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;<i class="fa fa-external-link-alt"></i></span></td>
<td>Test_1</td>
<td>2019-08-23 05:39:02</td>
</tr>
</tbody></table>
<ul>
<li><p>第一次console中的sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        tbl.PK_VALUE </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        auto_increment_table tbl </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        tbl.PK_NAME<span class="operator">=</span>? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line">            </span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        auto_increment_table</span><br><span class="line">        (PK_NAME, PK_VALUE)  </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?,?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        auto_increment_table </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        PK_VALUE<span class="operator">=</span>?  </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        PK_VALUE<span class="operator">=</span>? </span><br><span class="line">        <span class="keyword">and</span> PK_NAME<span class="operator">=</span>?</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        tbl.PK_VALUE </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        auto_increment_table tbl </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        tbl.PK_NAME<span class="operator">=</span>? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line">            </span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        auto_increment_table </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        PK_VALUE<span class="operator">=</span>?  </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        PK_VALUE<span class="operator">=</span>? </span><br><span class="line">        <span class="keyword">and</span> PK_NAME<span class="operator">=</span>?</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        jpa_customers</span><br><span class="line">        (age, birthday, create_time, email, last_name, update_time, id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?, ?, ?, ?, ?, ?)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>之后的sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        tbl.PK_VALUE </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        auto_increment_table tbl </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        tbl.PK_NAME<span class="operator">=</span>? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line">            </span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        auto_increment_table </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        PK_VALUE<span class="operator">=</span>?  </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        PK_VALUE<span class="operator">=</span>? </span><br><span class="line">        <span class="keyword">and</span> PK_NAME<span class="operator">=</span>?</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        jpa_customers</span><br><span class="line">        (age, birthday, create_time, email, last_name, update_time, id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?, ?, ?, ?, ?, ?)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA使用指南-2</title>
    <url>/archives/7862.html</url>
    <content><![CDATA[<blockquote>
<p>文章承自<a href="https://www.sun1999.top/article/jpa%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-1.html">JPA使用指南-1</a></p>
<p>本文介绍 JPA 常用 API</p>
<p>Persistence -&gt; EntityManagerFactory -&gt; EntityManager -&gt; EntityTransaction</p>
</blockquote>
<a id="more"></a>

<h2 id="1-Persistence"><a href="#1-Persistence" class="headerlink" title="1. Persistence"></a>1. Persistence</h2><p>Persistence  类是用于获取 EntityManagerFactory 实例。该类包含一个名为 createEntityManagerFactory 的 静态方法 。</p>
<p>createEntityManagerFactory 方法有如下两个重载版本。</p>
<ul>
<li>（常用）带有一个参数的方法以 JPA 配置文件 persistence.xml 中的持久化单元名为参数</li>
<li>带有两个参数的方法：前一个参数含义相同，后一个参数 Map类型，用于设置 JPA 的相关属性，这时将忽略其它地方设置的属性。Map 对象的属性名必须是 JPA 实现库提供商的名字空间约定的属性名。</li>
</ul>
<h2 id="2-EntityManagerFactory"><a href="#2-EntityManagerFactory" class="headerlink" title="2. EntityManagerFactory"></a>2. EntityManagerFactory</h2><p>EntityManagerFactory 接口主要用来创建 EntityManager 实例。该接口约定了如下4个方法：</p>
<ul>
<li>（常用）createEntityManager()：用于创建实体管理器对象实例。</li>
<li>createEntityManager(Map map)：用于创建实体管理器对象实例的重载方法，Map 参数用于提供 EntityManager 的属性。</li>
<li>isOpen()：检查 EntityManagerFactory 是否处于打开状态。实体管理器工厂创建后一直处于打开状态，除非调用close()方法将其关闭。</li>
<li>（常用）close()：关闭 EntityManagerFactory 。 EntityManagerFactory 关闭后将释放所有资源，isOpen()方法测试将返回 false，其它方法将不能调用，否则将导致IllegalStateException异常。</li>
</ul>
<h2 id="3-EntityManager"><a href="#3-EntityManager" class="headerlink" title="3. EntityManager"></a>3. EntityManager</h2><p><strong>EntityManager 对象在一组实体类与底层数据源之间进行 O/R 映射的管理。</strong></p>
<p>在 JPA 规范中, EntityManager 是完成持久化操作的核心对象。实体作为普通 Java 对象，<strong>只有在调用 EntityManager 将其持久化后才会变成持久化对象。</strong></p>
<p>它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。</p>
<blockquote>
<p>PS:实体的状态:</p>
<ul>
<li>新建状态:   新创建的对象，尚未拥有持久性主键。</li>
<li>持久化状态：已经拥有持久性主键并和持久化建立了上下文环境</li>
<li>游离状态：拥有持久化主键，但是没有与持久化建立上下文环境</li>
<li>删除状态:  拥有持久化主键，已经和持久化建立上下文环境，但是从数据库中删除。</li>
</ul>
</blockquote>
<ul>
<li><p>基本方法测试</p>
<ul>
<li>find (Class<T> entityClass,Object primaryKey)</li>
<li>getReference(Class<T> entityClass,Object primaryKey)</li>
<li>persist(Object entity)</li>
<li>remove(Object entity)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sust;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sust.entity.Customer;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityTransaction;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityManagerTest1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> EntityManagerFactory entityManagerFactory;</span><br><span class="line"><span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"><span class="keyword">private</span> EntityTransaction transaction;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1.testFind()</span></span><br><span class="line"><span class="comment">//        Customer customer = testFind(1);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;--------Before use customer--------&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(customer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        2.testGetReference()</span></span><br><span class="line"><span class="comment">//        Customer customer = testGetReference(1);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;--------Before use customer--------&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(customer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        3.testPersist() 注：插入10条数据，并且每一个customer都被持久化，获得了数据库自增id字段的值</span></span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt;= 10; i++) &#123;</span></span><br><span class="line"><span class="comment">//            Customer customer = new Customer();</span></span><br><span class="line"><span class="comment">//            customer.setLastName(&quot;testPersist_&quot; + i);</span></span><br><span class="line"><span class="comment">//            customer.setAge(new Random().nextInt(100));</span></span><br><span class="line"><span class="comment">//            customer.setEmail(new Random().nextInt(99999) + &quot;@sust.edu.cn&quot;);</span></span><br><span class="line"><span class="comment">//            testPersist(customer);</span></span><br><span class="line"><span class="comment">//            System.out.println(customer.getId());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        4.testRemove() 注：方法作用于持久化状态的对象，故需要查询用ID出来才可以删除！</span></span><br><span class="line"><span class="comment">//        Customer customer = testFind(1);</span></span><br><span class="line"><span class="comment">//        testRemove(customer);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* find (Class&lt;T&gt; entityClass,Object primaryKey)</span></span><br><span class="line"><span class="comment">* 直接返回持久化对象（缓存中没有就查数据库），不存在则返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Customer <span class="title">testFind</span><span class="params">(Integer primaryKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> entityManager.find(Customer.class, primaryKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getReference(Class&lt;T&gt; entityClass,Object primaryKey)</span></span><br><span class="line"><span class="comment">* 懒加载，返回entityClass的代理，</span></span><br><span class="line"><span class="comment">* 当用到返回代理类时执行真正的查询</span></span><br><span class="line"><span class="comment">* 如果此entity在数据库中不存在，getReference()会抛出EntityNotFoundException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Customer <span class="title">testGetReference</span><span class="params">(Integer primaryKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> entityManager.getReference(Customer.class, primaryKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 方法传入的将要被持久化的对象不能拥有ID（即临时对象），否则持久化失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPersist</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">entityManager.persist(customer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* remove(Object entity)</span></span><br><span class="line"><span class="comment">* 方法作用于持久化状态的对象，故需要查询用ID出来才可以删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRemove</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">entityManager.remove(customer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 直接update了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">Customer customer = entityManager.find(Customer.class, <span class="number">13</span>);</span><br><span class="line">customer.setAge(<span class="number">19</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">entityManagerFactory = Persistence.createEntityManagerFactory(<span class="string">&quot;myPersistenceUnit-1&quot;</span>);</span><br><span class="line">entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line">transaction = entityManager.getTransaction();</span><br><span class="line">transaction.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">transaction.commit();</span><br><span class="line">entityManager.close();</span><br><span class="line">entityManagerFactory.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>merge (T entity) 方法</strong></p>
<p>merge() 用于处理 Entity 的同步。即数据库的插入和更新操作</p>
<p>简单来说：</p>
<ol>
<li>传入的entity若无主键，则会执行insert，并返回一个新的持久化对象   </li>
<li>传入entity若有主键，但数据库不存在此主键，则会执行insert，并返回一个新的持久化对象</li>
<li>传入entity若有主键，且数据库已存在此主键，则进行update操作，并返回一个新的持久化对象 </li>
</ol>
<blockquote>
<p>注意，第三种情况这里有个大坑</p>
<p>如果你传入的游离对象，没有填入所有属性，那么这些属性会在update时被填入Null，</p>
<p>即使加入@DynamicUpdate也没用</p>
<p>这是因为merge()第三种情况update时存在一个属性拷贝，具体可以参照流程图，不详细介绍</p>
</blockquote>
<p>流程图：</p>
<p><img src="http://image.sun1999.top/20190823173249.png"></p>
<p>用merage()模拟update操作：（不知道有啥用）</p>
<blockquote>
<p>且要先将所更新的对象查出，也就是我们要将更改的数据填入查询出对象中，对其重新持久化（这里面也存在一个复制操作），而不是直接传入一个新建对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer foundedCustomer = entityManager.find(Customer.class, <span class="number">13</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------After find()&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;foundedCustomer:&quot;</span> + foundedCustomer);</span><br><span class="line">    <span class="keyword">if</span> (foundedCustomer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;米有此条目&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新字段</span></span><br><span class="line">    foundedCustomer.setLastName(<span class="string">&quot;13&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Customer mergedCustomer = entityManager.merge(foundedCustomer);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------After merge()&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mergedCustomer:&quot;</span> + mergedCustomer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交</span></span><br><span class="line">    transaction.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;-------After commit()&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mergedCustomer:&quot;</span> + mergedCustomer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>console打印的主要信息</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        customer0_.id <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">        customer0_.age <span class="keyword">as</span> age2_0_0_,</span><br><span class="line">        customer0_.birthday <span class="keyword">as</span> birthday3_0_0_,</span><br><span class="line">      customer0_.create_time <span class="keyword">as</span> create_t4_0_0_,</span><br><span class="line">        customer0_.email <span class="keyword">as</span> email5_0_0_,</span><br><span class="line">        customer0_.last_name <span class="keyword">as</span> last_nam6_0_0_,</span><br><span class="line">        customer0_.update_time <span class="keyword">as</span> update_t7_0_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        jpa_customers customer0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        customer0_.id<span class="operator">=</span>?</span><br><span class="line"><span class="comment">-------After find()</span></span><br><span class="line">foundedCustomer:Customer(id<span class="operator">=</span><span class="number">13</span>, email<span class="operator">=</span><span class="number">0</span>, lastName<span class="operator">=</span><span class="number">11</span>, age<span class="operator">=</span><span class="number">0</span>, createTime<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">32</span>:<span class="number">25.908</span>, updateTime<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span> <span class="number">19</span>:<span class="number">00</span>:<span class="number">18.515</span>, birthday<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span>)</span><br><span class="line"><span class="comment">-------After merge()</span></span><br><span class="line">mergedCustomer:Customer(id<span class="operator">=</span><span class="number">13</span>, email<span class="operator">=</span><span class="number">0</span>, lastName<span class="operator">=</span><span class="number">13</span>, age<span class="operator">=</span><span class="number">0</span>, createTime<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">32</span>:<span class="number">25.908</span>, updateTime<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span> <span class="number">19</span>:<span class="number">00</span>:<span class="number">18.515</span>, birthday<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span>)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        jpa_customers </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        age<span class="operator">=</span>?,</span><br><span class="line">        last_name<span class="operator">=</span>?,</span><br><span class="line">        update_time<span class="operator">=</span>? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        id<span class="operator">=</span>?</span><br><span class="line"><span class="comment">-------After commit()//注意提交后的updateTime字段</span></span><br><span class="line">mergedCustomer:Customer(id<span class="operator">=</span><span class="number">13</span>, email<span class="operator">=</span><span class="number">0</span>, lastName<span class="operator">=</span><span class="number">13</span>, age<span class="operator">=</span><span class="number">0</span>, createTime<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">32</span>:<span class="number">25.908</span>, updateTime<span class="operator">=</span>Fri Aug <span class="number">23</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">54</span> CST <span class="number">2019</span>, birthday<span class="operator">=</span><span class="number">2019</span><span class="number">-08</span><span class="number">-23</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>由以上实验得出结论：</p>
<p>我们在做更新操作时，merge()之后，其返回的持久化对象实际<strong>并没有更新</strong>，因为没有提交事务，还未与数据库通信。</p>
<p>我们要想安全的使用更新后的对象（保证所有字段与数据库相同，如例子中的updateTime字段）就必须在<code>transaction.commit();</code>之后使用merge()所返回的对象   </p>
</li>
<li><p>其余一些常用方法：</p>
<ul>
<li>flush ()：同步持久上下文环境，即将持久上下文环境的所有未保存实体的状态信息保存到数据库中。</li>
<li>refresh (Object entity)：用数据库实体记录的值更新实体对象的状态，即更新实例的属性值。</li>
<li>clear ()：清除持久上下文环境，断开所有关联的实体。如果这时还有未提交的更新则会被撤消。</li>
<li>contains (Object entity)：判断一个实例是否属于当前持久上下文环境管理的实体。</li>
<li>isOpen ()：判断当前的实体管理器是否是打开状态。</li>
<li>getTransaction ()：返回资源层的事务对象。EntityTransaction实例可以用于开始和提交多个事务。</li>
<li>close ()：关闭实体管理器。之后若调用实体管理器实例的方法或其派生的查询对象的方法都将抛出 IllegalstateException 异常，除了getTransaction 和 isOpen方法(返回 false)。不过，当与实体管理器关联的事务处于活动状态时，调用 close 方法后持久上下文将仍处于被管理状态，直到事务完成。</li>
</ul>
</li>
<li><p>JPQL方法：</p>
<ul>
<li>createQuery (String qlString)：创建一个查询对象。</li>
<li>createNamedQuery (String name)：根据命名的查询语句块创建查询对象。参数为命名的查询语句。</li>
<li>createNativeQuery (String sqlString)：使用标准 SQL语句创建查询对象。参数为标准SQL语句字符串。</li>
<li>createNativeQuery (String sqls, String resultSetMapping)：使用标准SQL语句创建查询对象，并指定返回结果集 Map的 名称。</li>
</ul>
</li>
</ul>
<h2 id="4-EntityTransaction"><a href="#4-EntityTransaction" class="headerlink" title="4.  EntityTransaction"></a>4.  EntityTransaction</h2><p>EntityTransaction 接口用来管理资源层实体管理器的事务操作。通过调用实体管理器的getTransaction方法 获得其实例。</p>
<ul>
<li><p>begin () 用于启动一个事务，此后的多个数据库操作将作为整体被提交或撤消。若这时事务已启动则会抛出 IllegalStateException 异常。</p>
</li>
<li><p>commit () 用于提交当前事务。即将事务启动以后的所有数据库更新操作持久化至数据库中。</p>
</li>
<li><p>rollback () 撤消(回滚)当前事务。即撤消事务启动后的所有数据库更新操作，从而不对数据库产生影响。</p>
</li>
<li><p>setRollbackOnly () 使当前事务只能被撤消。</p>
</li>
<li><p>getRollbackOnly () 查看当前事务是否设置了只能撤消标志。</p>
</li>
<li><p>isActive () 查看当前事务是否是活动的。如果返回true则不能调用begin方法，否则将抛出 IllegalStateException 异常；如果返回 false 则不能调用 commit、rollback、setRollbackOnly 及 getRollbackOnly 方法，否则将抛出 IllegalStateException 异常。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA使用指南-3</title>
    <url>/archives/56951.html</url>
    <content><![CDATA[<blockquote>
<p>文章承自<a href="https://www.sun1999.top/article/JPA%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-2.html">JPA使用指南-2</a></p>
<p>本文介绍映射关联关系</p>
<p>单向多对一；单向一对多；双向多对一；双向一对一；双向多对多</p>
</blockquote>
<a id="more"></a>

<h2 id="1-单向多对一"><a href="#1-单向多对一" class="headerlink" title="1.单向多对一"></a>1.单向多对一</h2><ul>
<li>创建Order实体类，Order与Customer的关系为多对一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sust.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ·<span class="doctag">@ManyToOne</span>·单向多对一，即多个Order对应一个Customer，在Order表中以Customer实体字段表现</span></span><br><span class="line"><span class="comment">     *				cascade 属性可以配置级联操作</span></span><br><span class="line"><span class="comment">     *				fetch 默认为 FetchType.EAGER</span></span><br><span class="line"><span class="comment">     * ·<span class="doctag">@JoinColumn</span>·指定关联中Order与CustomerId左外连接的列名(即Order表外键名)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试后会自动创建<code>jpa_orders</code>表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `jpa_orders` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `order_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `customer_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `FKd24gr5y1e7xklyx35mqxf51g8` (`customer_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `FKd24gr5y1e7xklyx35mqxf51g8` <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (`customer_id`) <span class="keyword">REFERENCES</span> `jpa_customers` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>


<h2 id="2-单向一对多"><a href="#2-单向一对多" class="headerlink" title="2. 单向一对多"></a>2. 单向一对多</h2><ul>
<li>准备<ul>
<li>注释掉Order实体中的Customer字段</li>
<li>更改Customer，<strong>在其中添加Order集合字段</strong></li>
</ul>
</li>
<li>运行测试后同样创建与单向多对一相同的<code>jpa_orders</code>表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略掉了无关代码，完整Customer请见 指南-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ·<span class="doctag">@OneToMany</span>·单向一对多，即一个Customer对应多个Order，在Customer中以Order集合的形式表现</span></span><br><span class="line"><span class="comment">     *				cascade 属性可以配置级联操作</span></span><br><span class="line"><span class="comment">     *				fetch 默认为 FetchType.LAZY</span></span><br><span class="line"><span class="comment">     * ·<span class="doctag">@JoinColumn</span>·映射外键列，注意这里生成的外键列照样在Order表中,与多对一生成的表结构相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-双向多对一"><a href="#3-双向多对一" class="headerlink" title="3.双向多对一"></a>3.双向多对一</h2><blockquote>
<ul>
<li><p><code>双向多对一 </code>即 <code>单向多对一</code> + <code>单向一对多</code> </p>
</li>
<li><p>注意相关联的 <code>JoinColumn</code>的<code>name</code> 字段，也就是<code>多端外键列名</code> 应相等</p>
<ul>
<li>Customer：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>Order：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里注意，操作双向多对一时，我们应让<code>多</code>端，即Order来维护关联关系，这样可以有效减少向数据库发送的为了维护关联关系所产生的sql语句</p>
<p><strong>简而言之就是持久化操作时，应先持久化Customer，再持久化Order</strong></p>
</li>
</ul>
</blockquote>
<p>以上所展示的写法可以实现双向多对一，但是JPA为了维护关联关系会产生额外的sql语句（这里Customer与Order都定义了需要维护的字段）   </p>
<p>故我们在使用<code>双向多对一</code>时应尽量采用以下方式:</p>
<hr>
<ul>
<li><p>Customer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *这里的mappedBy所指向的是被<span class="doctag">@JoinColumn</span>注解过的字段在java中的变量名</span></span><br><span class="line"><span class="comment"> *简单来说也就是将维护Customer与Order映射关系的任务都交给了Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@OneToMany(fetch = FetchType.LAZY,mappedBy = &quot;customer&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p>Order:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br></pre></td></tr></table></figure></li>
<li><p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoubleManyToMany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setAge(i);</span><br><span class="line">    customer.setEmail(i + <span class="string">&quot;@sust.edu.cn&quot;</span>);</span><br><span class="line">    customer.setLastName(<span class="string">&quot;testDoubleManyToMany_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;Order_&quot;</span> + i);</span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;Order_&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    customer.getOrderList().add(order1);</span><br><span class="line">    customer.getOrderList().add(order2);</span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line"></span><br><span class="line">    customer.setEmail(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">    customer.getOrderList().get(<span class="number">1</span>).setOrderName(<span class="string">&quot;&gt;&gt;&gt;???&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Order&gt; orderList = customer.getOrderList();</span><br><span class="line">    System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">        System.out.println(order.getOrderName() + <span class="string">&quot; : &quot;</span> +</span><br><span class="line">                           order.getCustomer().getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>console输出中的主要部分：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> jpa_customers (</span><br><span class="line">       id <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">        age TINYINT,</span><br><span class="line">        birthday <span class="type">date</span>,</span><br><span class="line">        create_time datetime(<span class="number">6</span>),</span><br><span class="line">        email <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">        last_name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">        update_time datetime(<span class="number">6</span>),</span><br><span class="line">        <span class="keyword">primary</span> <span class="keyword">key</span> (id)</span><br><span class="line">    ) engine<span class="operator">=</span>InnoDB</span><br><span class="line">八月 <span class="number">24</span>, <span class="number">2019</span> <span class="number">7</span>:<span class="number">32</span>:<span class="number">58</span> 下午 org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection</span><br><span class="line">INFO: HHH10001501: Connection obtained <span class="keyword">from</span> JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess<span class="variable">@1d035be3</span>] <span class="keyword">for</span> (non<span class="operator">-</span>JTA) DDL execution was <span class="keyword">not</span> <span class="keyword">in</span> auto<span class="operator">-</span><span class="keyword">commit</span> mode; the Connection <span class="string">&#x27;local transaction&#x27;</span> will be committed <span class="keyword">and</span> the Connection will be <span class="keyword">set</span> <span class="keyword">into</span> auto<span class="operator">-</span><span class="keyword">commit</span> mode.</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> jpa_orders (</span><br><span class="line">       id <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">        order_name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">        customer_id <span class="type">integer</span>,</span><br><span class="line">        <span class="keyword">primary</span> <span class="keyword">key</span> (id)</span><br><span class="line">    ) engine<span class="operator">=</span>InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> jpa_orders </span><br><span class="line">       <span class="keyword">add</span> <span class="keyword">constraint</span> FKd24gr5y1e7xklyx35mqxf51g8 </span><br><span class="line">       <span class="keyword">foreign</span> <span class="keyword">key</span> (customer_id) </span><br><span class="line">       <span class="keyword">references</span> jpa_customers (id)</span><br><span class="line">八月 <span class="number">24</span>, <span class="number">2019</span> <span class="number">7</span>:<span class="number">32</span>:<span class="number">58</span> 下午 org.hibernate.tool.schema.internal.SchemaCreatorImpl applyImportSources</span><br><span class="line">INFO: HHH000476: Executing import script <span class="string">&#x27;org.hibernate.tool.schema.internal.exec.ScriptSourceInputNonExistentImpl@58faa93b&#x27;</span></span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        jpa_customers</span><br><span class="line">        (age, birthday, create_time, email, last_name, update_time) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?, ?, ?, ?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        jpa_orders</span><br><span class="line">        (customer_id, order_name) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        jpa_orders</span><br><span class="line">        (customer_id, order_name) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line">Order_1 : <span class="operator">!</span><span class="operator">!</span><span class="operator">!</span></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="operator">&gt;</span>??? : <span class="operator">!</span><span class="operator">!</span><span class="operator">!</span></span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        jpa_customers </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        age<span class="operator">=</span>?,</span><br><span class="line">        email<span class="operator">=</span>?,</span><br><span class="line">        update_time<span class="operator">=</span>? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        id<span class="operator">=</span>?</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        jpa_orders </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        customer_id<span class="operator">=</span>?,</span><br><span class="line">        order_name<span class="operator">=</span>? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        id<span class="operator">=</span>?</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="4-双向一对一"><a href="#4-双向一对一" class="headerlink" title="4.双向一对一"></a>4.双向一对一</h2><ul>
<li><p>准备</p>
<ul>
<li><p>创建Department</p>
<ul>
<li><code>manager</code> 字段用<code>@OneToOne</code>来声明一对一关系，建议开启懒加载，否则查询会使用左外连接，效率比较差</li>
<li><code>@JoinColumn(name = &quot;manager_id&quot;, unique = true)</code> 则用来声明外键列名为<code>department_id</code>   </li>
<li>配置<code>unique</code>属性确保外键值唯一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_departments&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;manager_id&quot;, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> Manager manager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建Manager</p>
<ul>
<li><code>department</code> 字段用<code>@OneToOne</code>来声明一对一关系，需同样配置懒加载</li>
<li>配置<code>mappedBy</code>属性，将维护工作交给Department的<code>manager</code>属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_managers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;manager&quot;,fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String managerName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>插入测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">    manager.setAge(<span class="number">19</span>);</span><br><span class="line">    manager.setManagerName(<span class="string">&quot;菜虚鲲&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Department department = <span class="keyword">new</span> Department();</span><br><span class="line">    department.setDepartmentName(<span class="string">&quot;天庭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    department.setManager(manager);</span><br><span class="line">    manager.setDepartment(department);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里一定注意先持久化不维护关联关系的实体</span></span><br><span class="line"><span class="comment">     * 而由后持久化的对象负责维护关联关系</span></span><br><span class="line"><span class="comment">     * 否则多出的update外键列的语句会对效率有较大影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    entityManager.persist(manager);</span><br><span class="line">    entityManager.persist(department);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-双向多对多"><a href="#5-双向多对多" class="headerlink" title="5. 双向多对多"></a>5. 双向多对多</h2></li>
<li><p>创建Item</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_items&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;items_categories&quot;,</span></span><br><span class="line"><span class="meta">            joinColumns = &#123;@JoinColumn(name = &quot;items_id&quot;, </span></span><br><span class="line"><span class="meta">                                       referencedColumnName = &quot;id&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;categories_id&quot;, </span></span><br><span class="line"><span class="meta">                                              referencedColumnName = &quot;id&quot;)&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Category&gt; categoryList;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;item_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String itemName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@joinColumns</code> ：映射关联表，name指定关联表表名</li>
<li><code>joinColumns</code>属性：映射当前类所在表（jpa_items）在关联表（items_categories）中的外键(id)</li>
<li><code>inverseJoinColumns</code>属性：映射关联的实体类所对应的表（jpa_categories）在关联表中的外键(id)</li>
<li>注意<code>@JoinColumn</code>注解中，name属性只是对列的新命名，referencedColumnName才指定了主键，不过referencedColumnName可以省略，这样会默认映射到注释实体对应表的主键</li>
<li>默认启用懒加载哦~</li>
</ul>
</li>
<li><p>创建Category</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_categories&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;category_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;categoryList&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; itemList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里一定注意，多对多关系只配置一方(这里选择了Item)维护关系，故在另一方（Category），我们需要给<code>@ManyToMany</code>配置mappedBy属性（里面填存在维护关系注解的变量的名称）来托管维护</li>
</ul>
</li>
<li><p><code>@JoinTable</code> 所生成的表DDL:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `items_categories` (</span><br><span class="line">  `items_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `categories_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY `FKovymsahbi6ua0ubka76qbvb90` (`categories_id`),</span><br><span class="line">  KEY `FKn42kdeg73kpktyl367aw9ljck` (`items_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `FKn42kdeg73kpktyl367aw9ljck` </span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (`items_id`) <span class="keyword">REFERENCES</span> `jpa_items` (`id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `FKovymsahbi6ua0ubka76qbvb90` </span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (`categories_id`) <span class="keyword">REFERENCES</span> `jpa_categories` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式-匹配规则</title>
    <url>/archives/47645.html</url>
    <content><![CDATA[<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><table>
<thead>
<tr>
<th>符号</th>
<th>字符</th>
<th>正则</th>
<th>Java字符串</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>abc</code></td>
<td><code>abc</code></td>
<td><code>abc</code></td>
<td></td>
</tr>
<tr>
<td><code>\</code></td>
<td><code>a&amp;c</code></td>
<td><code>a\&amp;c</code></td>
<td><code>a\\&amp;c</code></td>
<td>正则中特殊字符需要<code>\</code>来表示转义，而Java字符串中需要表达正则中的转义标志<code>\</code>，则需要另一个<code>\</code>来转义正则中的<code>\</code>字符,<strong>故Java字符串中需要<code>\\</code>来表示转义</strong></td>
</tr>
<tr>
<td><code>\u####</code></td>
<td><code>a和c</code></td>
<td><code>a\u548cc</code></td>
<td></td>
<td>非ASCII字符用<code>\u####</code>表示</td>
</tr>
<tr>
<td><code>.</code></td>
<td><code>abc</code>,<code>a&amp;c</code></td>
<td><code>a.c</code></td>
<td><code>a.c</code></td>
<td><code>.</code>匹配任意字符,能且只能匹配一个,**这里不能用<code>\**</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td><code>007</code>,<code>008</code></td>
<td><code>00\d</code></td>
<td></td>
<td><code>\d</code>匹配数字,能且只能匹配一个</td>
</tr>
<tr>
<td><code>\D</code></td>
<td><code>00A</code>,<code>00#</code></td>
<td><code>00\D</code></td>
<td></td>
<td><code>\D</code>匹配<strong>非</strong>数字,能且只能匹配一个</td>
</tr>
<tr>
<td><code>\w</code></td>
<td><code>javac</code>,<code>java8</code>,<code>java_</code>,</td>
<td><code>java\w</code></td>
<td></td>
<td><code>\w</code>匹配字母、数字或下划线，能且只能匹配一个<br />注意不能匹配特殊字与Space，比如<code>java#</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td><code>java!</code>,<code>java(space)</code>,</td>
<td><code>java\W</code></td>
<td></td>
<td><code>\W</code>匹配<strong>非</strong>字母、数字或下划线，能且只能匹配一个<br />也就是可以特殊匹配字符与space</td>
</tr>
<tr>
<td><code>\s</code></td>
<td><code>A B</code>（space）                          <code>A    B</code>(tab)</td>
<td><code>A\sB</code></td>
<td></td>
<td><code>\s</code>匹配空白字符，能且只能匹配一个，且可以匹配<code>tab</code>字符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td><code>A&amp;B</code>,<code>AAB</code></td>
<td><code>A\sB</code></td>
<td></td>
<td><code>\S</code>匹配<strong>非</strong>空白字符</td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>A</code>,<code>A1</code>,<code>A007</code></td>
<td><code>A\d*</code></td>
<td></td>
<td>修饰符<code>*</code>匹配任意个字符<br />这里正则的含义是：首先匹配<code>A</code>字符,接着<strong>匹配任意个数字</strong></td>
</tr>
<tr>
<td><code>+</code></td>
<td><code>A1</code>,<code>A007</code></td>
<td><code>A\d+</code></td>
<td></td>
<td>修饰符<code>+</code>匹配至少一个字符<br />这里正则的含义是：首先匹配<code>A</code>字符,接着<strong>匹配至少一个数字</strong></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>A</code>,<code>A1</code>,<code>A&amp;</code></td>
<td><code>A\d?</code></td>
<td></td>
<td>修饰符<code>?</code>匹配零个或一个字符<br />这里正则的含义是：首先匹配<code>A</code>字符,接着<strong>匹配零个或一个数字</strong></td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td><code>123456</code>,<code>99999</code></td>
<td><code>\d&#123;6&#125;</code></td>
<td></td>
<td>修饰符<code>&#123;n&#125;</code>匹配n个字符<br />这里正则的含义是：<strong>匹配6个数字</strong></td>
</tr>
<tr>
<td><code>&#123;n，m&#125;</code></td>
<td><code>123</code>,<code>1234</code>,<code>12345</code></td>
<td><code>\d&#123;3,5&#125;</code></td>
<td></td>
<td>修饰符<code>&#123;n,m&#125;</code>匹配n-m个字符<br />这里正则的含义是：<strong>匹配3-5个数字</strong></td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td><code>123</code>,<code>12345678999</code></td>
<td><code>\d&#123;3,&#125;</code></td>
<td></td>
<td>修饰符<code>&#123;n,&#125;</code>匹配至少n个字符<br />这里正则的含义是：<strong>匹配至少3个数字</strong></td>
</tr>
</tbody></table>
<a id="more"></a>

<p>示例：判断用户输入的年份是否是19xx年</p>
<p>规则：<code>1 9  0-9 0-9</code></p>
<p>正则：<code>1 9   \d   \d</code></p>
<p>Java字符串：<code>&quot;19\\d\\d&quot;</code></p>
<p>Java代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String input = <span class="string">&quot;1990&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> is19xx = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(input!=<span class="keyword">null</span>)&#123;</span><br><span class="line">     is19xx = input.matches(<span class="string">&quot;19\\d\\d&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RegExp</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/archives/49545.html</url>
    <content><![CDATA[<blockquote>
<p>在Spring的学习中，总发现自己基础不扎实，JavaSE知识有所欠缺，所以决定抽空补一下，希望能拾起来忘掉的东西</p>
</blockquote>
<h2 id="一、注解的使用"><a href="#一、注解的使用" class="headerlink" title="一、注解的使用"></a>一、注解的使用</h2><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><ul>
<li>注解本身对代码逻辑没有任何影响</li>
<li>如何使用注解由工具决定</li>
</ul>
<a id="more"></a>

<h3 id="编译器使用的注解"><a href="#编译器使用的注解" class="headerlink" title="编译器使用的注解"></a>编译器使用的注解</h3><ol>
<li><code>@Override</code>：让编译器检查该方法是否正确的实现了覆写</li>
<li><code>@Deprecated</code>：告诉编译器该方法已经标记为“作废”，在在其他地方引用将会出现编译警告</li>
<li> <code>@SuppressWarnings</code>:让编译器忽略代码块中的编译警告</li>
</ol>
<h3 id="注解可以定义配置参数"><a href="#注解可以定义配置参数" class="headerlink" title="注解可以定义配置参数"></a>注解可以定义配置参数</h3><ol>
<li>配置参数由注解类型定义</li>
<li>配置参数可以包括：<ul>
<li>基本类型</li>
<li>String</li>
<li>枚举类型</li>
<li>数组</li>
</ul>
</li>
<li>配置参数必须是常量</li>
</ol>
<h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><ul>
<li>缺少某个配置参数将使用默认值</li>
<li>如果只写常量，相当于使用了<code>value</code>参数</li>
<li>如果只写注解，相当于全部使用默认值</li>
</ul>
<h2 id="二、定义注解"><a href="#二、定义注解" class="headerlink" title="二、定义注解"></a>二、定义注解</h2><p>使用<code>@Interface</code>定义注解</p>
<ul>
<li>注解的参数类似于无参数方法</li>
<li>可以设定一个默认值（推荐）</li>
<li>把最常用的参数命名为value（推荐）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> Report&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元注解（用来修饰其他注解）"><a href="#元注解（用来修饰其他注解）" class="headerlink" title="元注解（用来修饰其他注解）"></a>元注解（用来修饰其他注解）</h3><ol>
<li><p><code>@Target()</code></p>
<p>使用<code>@Target</code>定义<code>Annotation</code>可以被应用于源码的哪些位置</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code></li>
<li>字段：<code>ElementType.FIELD</code></li>
<li>方法：<code>ElementType.METHOD</code></li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code></li>
<li>方法参数：<code>ElementType.PARAMETER</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.TYPE,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> Report&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p><code>@Retention()</code></p>
<p>使用<code>@Retention</code>定义<code>Annotation</code>生命周期</p>
<ul>
<li><code>RetentionPolicy.RUNTIME</code>，运行期，在运行期可以用代码读取该<code>Annotation</code></li>
<li><code>RetentionPolicy.SOURCE</code>，仅编译期，编译器在编译时直接丢弃，例如<code>@Override</code></li>
<li><code>RetentionPolicy.CLASS</code>，仅class文件，该注解仅储存在<code>class</code>文件中，非常少见</li>
</ul>
<p><strong>通常自定义的<code>Annotation</code>都是<code>RUNTIME</code>，不要漏写</strong></p>
<p>如果<code>@Retention</code>不存在，则该 注解默认为<code>CLASS</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> Report&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>@Repeatable</code></p>
<p>使用<code>@Repeatable</code>定义<code>Annotation</code>是否可重复（JDK&gt;=1.8）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> Report&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Report(type=1,level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2,levle=&quot;warning&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Inherited</code></p>
<p>使用<code>Inherited</code>定义子类是否可以继承父类的<code>Annotation</code></p>
<ul>
<li>仅针对<code>@Target</code>为<code>TYPE</code>类型的<code>Annotation</code></li>
<li>仅针对<code>class</code>的继承，对<code>interface</code>的继承无效</li>
</ul>
<hr>
<p><strong>定义<code>Annotation</code>的步骤：</strong></p>
<ol>
<li>用<code>@interface</code>定义注解</li>
<li>用元注解（meta annotation）配置注解<ul>
<li><code>Target</code>:必须设置</li>
<li><code>Retention</code>:一般设置为<code>RUNTIME</code></li>
<li>通常不必写<code>@Inherited</code>,<code>@Repeatable</code></li>
</ul>
</li>
<li>定义注解参数和默认值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> Report&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="三、处理注解"><a href="#三、处理注解" class="headerlink" title="三、处理注解"></a>三、处理注解</h2><p><strong>在代码中我们使用反射机制来读取@Retention为RUNTIME的注解</strong></p>
<blockquote>
<p>所有的<code>Annotation</code>继承自<code>java.lang.annotation.Annotation</code></p>
</blockquote>
<p>可以通过工具处理注解来实现相应的功能</p>
<ul>
<li>对JavaBean的属性值按规则进行检查</li>
<li>JUnit会自动运行@Test注解的测试方法</li>
</ul>
<hr>
<p>反射API:</p>
<p>判断注解是否存在</p>
<ul>
<li>Class.isAnnotationPresent(Class)</li>
<li>Field.isAnnotationPresent(Class)</li>
<li>Method.isAnnotationPresent(Class)</li>
<li>Constructor.isAnnotationPresent(Class)</li>
</ul>
<p>获取注解，若该注解不存在则返回NULL</p>
<ul>
<li>Class.getAnnotation(Class)</li>
<li>Field.getAnnotation(Class)</li>
<li>Method.getAnnotation(Class)</li>
<li>Constructor.getAnnotation(Class)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line"><span class="keyword">if</span>(cls.isAnnotationPresent(Report.class))&#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--或者--</span></span><br><span class="line">Class cls = Person.class;</span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span>(report!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>读取方法参数的Annotation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里@NotNull与@Range为自定义注解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max5)</span> String name,<span class="meta">@NotNull</span> String prefix)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method m = ...;</span><br><span class="line">Range r;</span><br><span class="line"><span class="comment">//因为每一个参数可能有多个注解，一个方法本身又可以传入多个参数，故这里注解列表为二维数组</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">//获得第一个参数的注解列表</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Annotation anno : annosOfName)&#123;</span><br><span class="line">    <span class="comment">//取得第一个参数中类型为Range的注解</span></span><br><span class="line">    <span class="keyword">if</span>(anno <span class="keyword">instanceof</span> Range)&#123;</span><br><span class="line">        r = (Range)anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis实现模糊查询的几种方式</title>
    <url>/archives/19242.html</url>
    <content><![CDATA[<blockquote>
<p>这篇文章主要介绍了MyBatis实现模糊查询的几种方式，小编觉得挺不错的，现在分享给大家，也给大家做个参考。一起跟随小编过来看看吧</p>
</blockquote>
<p>在学习MyBatis过程中想实现模糊查询，可惜失败了。后来上百度上查了一下，算是解决了。记录一下MyBatis实现模糊查询的几种方式。 </p>
<a id="more"></a>

<p>数据库表名为test_student,初始化了几条记录，如图： </p>
<p><img src="http://image.sun1999.top/201808221103269.png"></p>
<p>起初我在MyBatis的mapper文件中是这样写的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;searchStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM test_student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27; and compare != null and compare != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age</span><br><span class="line">            $&#123;compare&#125;</span><br><span class="line">            #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND name LIKE &#x27;%#&#123;name&#125;%&#x27;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null and address != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND address LIKE &#x27;%#&#123;address&#125;%&#x27;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    ORDER BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>写完后自我感觉良好，很开心的就去跑程序了，结果当然是报错了： </p>
<p><img src="http://image.sun1999.top/2018082211032610.png"></p>
<p><strong>经百度得知，这么写经MyBatis转换后<code>(&#39;%#&#123;name&#125;%&#39;)</code>会变为<code>(&#39;%?%&#39;)</code>,而<code>(&#39;%?%&#39;)</code>会被看作是一个字符串，所以Java代码在执行找不到用于匹配参数的<code>?</code> ,然后就报错了。</strong></p>
<p><strong>解决方法</strong></p>
<ol>
<li>用${…}代替#{…}</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;searchStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM test_student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27; and compare != null and compare != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age</span><br><span class="line">            $&#123;compare&#125;</span><br><span class="line">            #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND name LIKE &#x27;%$&#123;name&#125;%&#x27;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null and address != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND address LIKE &#x27;%$&#123;address&#125;%&#x27;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    ORDER BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查询结果如下图： </p>
<p><img src="http://image.sun1999.top/2018082211032611.jpg"></p>
<p><em>注：使用${…}不能有效防止SQL注入，所以这种方式虽然简单但是不推荐使用！！！</em></p>
<ol start="2">
<li>把<code>&#39;%#&#123;name&#125;%&#39;</code>改为<code>&quot;%&quot;#&#123;name&#125;&quot;%&quot;</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;searchStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM test_student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27; and compare != null and compare != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age</span><br><span class="line">            $&#123;compare&#125;</span><br><span class="line">            #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND name LIKE &quot;%&quot;#&#123;name&#125;&quot;%&quot;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null and address != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND address LIKE &quot;%&quot;#&#123;address&#125;&quot;%&quot;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    ORDER BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查询结果： </p>
<p><img src="http://image.sun1999.top/2018082211032612.png"></p>
<ol start="3">
<li>使用sql中的字符串拼接函数</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;searchStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM test_student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27; and compare != null and compare != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age</span><br><span class="line">            $&#123;compare&#125;</span><br><span class="line">            #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND name LIKE CONCAT(CONCAT(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;))</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null and address != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND address LIKE CONCAT(CONCAT(&#x27;%&#x27;,#&#123;address&#125;,&#x27;%&#x27;))</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    ORDER BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查询结果： </p>
<p><img src="http://image.sun1999.top/2018082211032613.png"></p>
<ol start="4">
<li>使用标签</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;searchStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.StudentEntity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.name + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.address + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">    SELECT * FROM test_student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27; and compare != null and compare != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age</span><br><span class="line">            $&#123;compare&#125;</span><br><span class="line">            #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND name LIKE #&#123;pattern1&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null and address != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND address LIKE #&#123;pattern2&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    ORDER BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查询结果： </p>
<p><img src="http://image.sun1999.top/2018082211032614.png"></p>
<ol start="5">
<li>在Java代码中拼接字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        testString(count);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> time = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;String 方法拼接&quot;</span>+count+<span class="string">&quot;次消耗时间：&quot;</span> + time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        testStringBuilder(count);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        time = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder 方法拼接&quot;</span>+count+<span class="string">&quot;次消耗时间：&quot;</span> + time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">testString</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        result += <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">testStringBuilder</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p>
<blockquote>
<p>文章转载自 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8xNDYwODAuaHRt">脚本之家<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis总结[转载]</title>
    <url>/archives/16793.html</url>
    <content><![CDATA[<h3 id="这里贴两条转载，很有帮助，多谢作者分享"><a href="#这里贴两条转载，很有帮助，多谢作者分享" class="headerlink" title="这里贴两条转载，很有帮助，多谢作者分享~"></a>这里贴两条转载，很有帮助，多谢作者分享~</h3><p><a href="https://blog.csdn.net/ITITII/article/details/79969447"><strong>Mybatis全面详解——上（学习总结）</strong></a></p>
<p><a href="https://blog.csdn.net/ITITII/article/details/79999481"><strong>Mybatis全面详解——下（学习总结）</strong></a></p>
<blockquote>
<p> 作者:<span class="exturl" data-url="aHR0cHM6Ly9tZS5jc2RuLm5ldC9ibG9nL0lUSVRJSQ==">窈窕淑女_梦寐求之<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb开发之ServletFilter</title>
    <url>/archives/59719.html</url>
    <content><![CDATA[<blockquote>
<p>好文收藏  <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwODc1MTMvYXJ0aWNsZS9kZXRhaWxzLzU2ODM1ODk0">https://blog.csdn.net/u013087513/article/details/56835894<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Filter</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM基本项目模块架构</title>
    <url>/archives/34532.html</url>
    <content><![CDATA[<h2 id="项目模块划分"><a href="#项目模块划分" class="headerlink" title="项目模块划分"></a>项目模块划分</h2><ol>
<li><strong>父模块</strong></li>
</ol>
<ul>
<li>全局定义与组织</li>
<li>整合dao、biz、web</li>
</ul>
<ol start="2">
<li><strong>dao模块-持久层</strong></li>
</ol>
<ul>
<li>Mybatis依赖、Spring依赖</li>
<li>Mybatis与Spring整合</li>
<li>spring-beans 、spring-context、spring-jdbc、mysql-connector-java、mybatis、mybatis-spring</li>
</ul>
<ol start="3">
<li><strong>biz模块-业务层</strong></li>
</ol>
<ul>
<li>依赖持久层(dao)</li>
<li>AspectJ依赖、AOP依赖、事务相关封装</li>
<li>spring-tx、spring-aop、aspectj</li>
</ul>
<ol start="4">
<li><strong>web模块-表现层(maven-archetype-webapp)、(war包)</strong></li>
</ol>
<ul>
<li><p>依赖业务层(biz)</p>
</li>
<li><p>Servlet依赖、Spring MVC依赖</p>
</li>
<li><p>spring-web、spring-mvc、javax-servlet-api、jstl</p>
<h2 id="包及全局配置"><a href="#包及全局配置" class="headerlink" title="包及全局配置"></a>包及全局配置</h2></li>
</ul>
<ol>
<li><strong>dao</strong></li>
</ol>
<ul>
<li>dao、entity、global(存放数据字典类)</li>
<li>数据源(<code>org.springframework.jdbc.datasource.DriverManagerDataSource</code>)</li>
<li>Session工厂(<code>org.mybatis.spring.SqlSessionFactoryBean</code>)</li>
<li>映射器接口(<code>org.mybatis.spring.mapper.MapperScannerConfigurer</code>) </li>
</ul>
<ol start="2">
<li><strong>biz</strong></li>
</ol>
<ul>
<li><p>事务(<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code></p>
<p><code>&lt;tx:advice id=&quot;transactionInterceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;</code>)</p>
</li>
<li><p>自动扫描（<code>&lt;context:component-scan base-package=&quot;com.sust.biz&quot;/&gt;</code> </p>
<p><code> &lt;aop:aspectj-autoproxy/&gt;</code>）</p>
</li>
</ul>
<ol start="3">
<li><strong>web</strong></li>
</ol>
<ul>
<li>controller、dto、global</li>
<li>Spring MVC加载(<code>org.springframework.web.servlet.DispatcherServlet</code> <code>/</code>)</li>
<li>   静态资源处理(<code>&lt;mvc:default-servlet-handler/&gt;</code>)</li>
<li>   视图转换器(<code>org.springframework.web.servlet.view.InternalResourceViewResolver</code> <code>这个用来解析jsp视图</code>)</li>
<li>   编码过滤器（<code>org.springframework.web.filter.CharacterEncodingFilter</code> 其中配置 <code>encoding</code>与<code>forceEncoding</code> <code>/*</code>）</li>
<li>   自动扫描(<code>&lt;context:component-scan base-package=&quot;com.sust.controller&quot;/&gt;</code>)</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot快速入门</title>
    <url>/archives/2197.html</url>
    <content><![CDATA[<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首先，配置文件我们一般用<code>yml</code>格式，且可以分环境在<code>classpath</code>下，创建<code>application.yml</code>为主配置文件</p>
<p>下来可以创建文件名规范为<code>application-__.yml</code>的yml文件</p>
<p>例如<code>application-dev.yml</code>,<code>application-prod.yml</code></p>
<p>在主配置文件<code>application.yml</code>做以下配置，即可使用<code>application-dev.yml</code>下的配置信息；</p>
<p>注意，无论使用哪个子配置文件，主配置文件中的配置都会生效（相当于通用配置），若子配置文件覆盖掉主配置文件中的相同信息，则最终为子文件中的配置</p>
<a id="more"></a>

<p>一些基本配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/your-context-path</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">  	<span class="comment">#选用dev配置文件</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/dataBaseName?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">    <span class="comment">#第一次运行使用create自动生成表，一般使用update</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">create</span></span><br><span class="line">    <span class="comment">#控制台打印出SQL语句</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#使用MySQL方言，为了自动生成数据库时使用InnoDB</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL8Dialect</span></span><br></pre></td></tr></table></figure>


<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><ol>
<li><p>开发工具启动</p>
</li>
<li><p>项目目录下执行 ：<code>mvn springboot:run</code></p>
</li>
<li><p>生产环境</p>
<ol>
<li><p>项目目录下执行 <code>mvn clean package</code>编译项目</p>
</li>
<li><p>成功后执行<code>cd target</code>进入编译生成的target目录</p>
</li>
<li><p>执行<code>java -jar JAR包文件名</code> 启动（这里启动时，可以配置参数，以指定SpringBoot的配置文件）</p>
<p><code>java -jar 文件名.jar --spring.profiles.active=prod  </code>这样就可以用<code>application-prod.yml</code>启动</p>
</li>
</ol>
</li>
</ol>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yml:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##自定义配置1（使用@Value注入变量）</span></span><br><span class="line"><span class="attr">customParameter1:</span></span><br><span class="line">	<span class="attr">sonPara:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">####使用配置文件中的参数：customParameter2 的实际值为&quot;最小数为1&quot;</span></span><br><span class="line"><span class="attr">customParameter2:</span> <span class="string">最小数为$&#123;customParameter1.sonPara&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##自定义配置2(直接注入对象)</span></span><br><span class="line"><span class="attr">limit:</span></span><br><span class="line">	<span class="attr">ANum:</span> <span class="number">1</span></span><br><span class="line">	<span class="attr">BNum:</span> <span class="string">$&#123;limit.minNum&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@Value(&quot;&quot;)</code>  用在 配置变量 的定义上</p>
<p>主要用于单个自定义配置 </p>
<p>配置文件中自定义的参数<code>0</code>注入类变量 ,相比于下面的配置类批量注入来说比较繁琐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CustomParConfig.java</span></span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;customParameter1&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String myCustomPar1;</span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;customParameter2&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String myCustomPar2;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@ConfigurationProperties(perfix = &quot;&quot;)</code>配合<code>@Component</code> 写在配置类上</p>
<p>主要用于多个自定义配置</p>
<p>该注释可直接将自定义配置批量注入配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LimitConfig.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;limit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer ANum;</span><br><span class="line">    <span class="keyword">private</span> Integer BNum;</span><br><span class="line">    <span class="comment">//省略get()和set()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接将 .yml 中的参数封装到配置类中，其他地方获取只需用@Autowired注入即可</p>
<hr>
</li>
<li><p><code>@RestController</code> 用在Contorller类上</p>
<p>代替了@Controller，并且还相当于在类的所有方法上都加@ResponseBody注解，即该类下的所有方法都会返回字符串，一般用于返回json格式数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类中访问根url为http://localhost:8080/hw/...</span></span><br><span class="line"><span class="meta">@RestController()</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//omit....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>@RequestMapping</code>配置url映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//postman中以POST请求访问url：url:http://localhost:8080/hw/say</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/say&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;100&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//页面返回值：100</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>@___Mapping</code>系列：GetMapping ,PostMapping,</p>
<p>映射单个url:@GetMapping(“url”)</p>
<p>映射多个url:@GetMapping({“/url1”,”/url2”})</p>
</li>
<li><p><code>@PathVariable(&quot;&quot;)</code> 获取url中的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//url:http://localhost:8080/hw/say/100</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/say/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer myId )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(myId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//页面返回值：100</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>@RequestParam(&quot;&quot;)</code> 获取请求参数的值，也可以选择不传参数，使用默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestParam( value = &quot;id&quot;,required = false,defaultValue = &quot;0&quot;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//url:http://localhost:8080/hw/say?100</span></span><br><span class="line"><span class="comment">//或者url:http://localhost:8080/hw/say</span></span><br><span class="line"><span class="comment">//使用form-urlencoded</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/say&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span>Integer myId )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(myId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//页面返回值：100</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用JPA自动创建表时，有如下的yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">    <span class="comment">#第一次运行使用create自动生成表，一般使用update</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">create</span></span><br><span class="line">    <span class="comment">#控制台打印出SQL语句</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#使用MySQL方言，为了自动生成数据库时使用InnoDB</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL8Dialect</span></span><br></pre></td></tr></table></figure>
<p>相应的实体类的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*注意，以下注解都为：&#x27;javax.persistence&#x27;包下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Entity</span><span class="comment">//声明需要自动创建表的实体类</span></span><br><span class="line"><span class="meta">@Table(&quot;table_name&quot;)</span><span class="comment">//指定表名，缺省值为驼峰类名的转换:lucky_money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *&#x27;@id&#x27; 指定主键</span></span><br><span class="line"><span class="comment">    *&#x27;@GeneratedValue&#x27; 配置自增列，并声明自增策略</span></span><br><span class="line"><span class="comment">    *详情参见：&#x27;https://blog.csdn.net/zhangli0910/article/details/83580855&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须有一个无参构造器</span></span><br><span class="line">    MyEntity()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>@Transactional</code> 用在映射方法上，使方法中的服务以事务执行</p>
<p>// org.springframework.transaction.annotation.Transactional</p>
</li>
</ul>
<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>最基本的API设计</p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>请求路径</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/context-path</td>
<td>查询条目列表</td>
</tr>
<tr>
<td>POST</td>
<td>/context-path</td>
<td>创建单个记录</td>
</tr>
<tr>
<td>GET</td>
<td>/context-path/id</td>
<td>查询单个记录</td>
</tr>
<tr>
<td>PUT</td>
<td>/context-path/id</td>
<td>更新单个记录</td>
</tr>
<tr>
<td>DELETE</td>
<td>/context-path/id</td>
<td>删除单个记录</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/archives/6244.html</url>
    <content><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul>
<li><p><strong>Aspect Oriented Programming 的缩写，意为：面向切面编程，通过 预编译方式 和 运行期动态代理 实现程序功能的统一维护的一种技术</strong></p>
</li>
<li><p>主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等</p>
</li>
</ul>
<a id="more"></a>

<h2 id="AOP的实现方式"><a href="#AOP的实现方式" class="headerlink" title="AOP的实现方式"></a>AOP的实现方式</h2><ul>
<li>预编译    AspectJ</li>
<li>运行期动态代理（JDK动态代理、CGLib动态代理）：Spring AOP、Jboss AOP</li>
</ul>
<h2 id="AOP的相关概念"><a href="#AOP的相关概念" class="headerlink" title="AOP的相关概念"></a>AOP的相关概念</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>切面（Aspect)</td>
<td>一个关注点的<strong>模块化</strong>，这个关注点可能会横切多个对象</td>
</tr>
<tr>
<td>连接点(Join point)</td>
<td>程序执行过程中的某个特定的点</td>
</tr>
<tr>
<td>通知（Advice)</td>
<td>在切面的某个特定的连接点上执行的动作</td>
</tr>
<tr>
<td>切入点(Pointcut)</td>
<td>匹配连接点的断言，在AOP中通知和一个切入点表达式关联</td>
</tr>
<tr>
<td>引入(Introduction)</td>
<td>在不修改类代码的前提下，为类添加新的方法和属性</td>
</tr>
<tr>
<td>目标对象（Target Object)</td>
<td>被一个或者多个切面所通知的对象</td>
</tr>
<tr>
<td>AOP代理(AOP Proxy)</td>
<td>AOP框架创建的对象，用来实现切面契约(aspect contract)(包括通知方法执行等功能)</td>
</tr>
<tr>
<td>织入(Weaving)</td>
<td>把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入、类加载时织入、执行时织入</td>
</tr>
</tbody></table>
<ul>
<li> 形象点的解释<br>  <img src="http://image.sun1999.top/20190519162426.png"></li>
</ul>
<h2 id="通知（Advice"><a href="#通知（Advice" class="headerlink" title="通知（Advice)"></a>通知（Advice)</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知（Before advice)</td>
<td>在某连接点（join point）之前执行的通知，但不能阻止连接点前的执行（除非它抛出一个异常)</td>
</tr>
<tr>
<td>返回后通知(After returning advice)</td>
<td>在某连接点（join point）正常完成后执行的通知</td>
</tr>
<tr>
<td>抛出异常后通知(After throwing advice)</td>
<td>在方法抛出异常退出时执行的通知</td>
</tr>
<tr>
<td>后通知(After(finally)advice)</td>
<td>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出)</td>
</tr>
<tr>
<td>环绕通知(Around Advice)</td>
<td>包围一个连接点（join point）的通知</td>
</tr>
</tbody></table>
<h2 id="Spring-框架中-AOP-的用途"><a href="#Spring-框架中-AOP-的用途" class="headerlink" title="Spring 框架中 AOP 的用途"></a>Spring 框架中 AOP 的用途</h2><ul>
<li>提供了声明式的企业服务，特别是EJB的替代服务的声明</li>
<li>允许用户定制自己的方面，以完成OOP与AOP的互补使用</li>
</ul>
<h2 id="Spring-的-AOP-实现"><a href="#Spring-的-AOP-实现" class="headerlink" title="Spring 的 AOP 实现"></a>Spring 的 AOP 实现</h2><ul>
<li>纯java实现，无需特殊的编译过程，不需要控制类加载器层次目前只支持方法执行连接点（通知Spring Bean的方法执行）</li>
<li>不是为了提供最完整的AOP实现（尽管它非常强大）；而是侧重于提供一种AOP实现和Spring IoC容器之间的整合，用于帮助解决应用中的常见问题</li>
<li>Spring AOP不会与 AspectJ 竞争，从而提供综合全面的 AOP 解决方案</li>
</ul>
<h2 id="有接口和无接口的-Spring-AOP实现区别"><a href="#有接口和无接口的-Spring-AOP实现区别" class="headerlink" title="有接口和无接口的 Spring AOP实现区别"></a>有接口和无接口的 Spring AOP实现区别</h2><ul>
<li>Spring AOP默认使用标准的JavaSE动态代理作为AOP代理，这使得任何接口（或者接口集）都可以被代理</li>
<li>Spring AOP中也可以使用CGLIB代理(如果一个业务对象并没有实现一个接口）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的简介</title>
    <url>/archives/14570.html</url>
    <content><![CDATA[<h2 id="Bean标签作用："><a href="#Bean标签作用：" class="headerlink" title="Bean标签作用："></a>Bean标签作用：</h2><ul>
<li><p>用于配置对象让 spring 来创建的。</p>
</li>
<li><p>默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p>
<a id="more"></a>
<h2 id="Bean标签属性："><a href="#Bean标签属性：" class="headerlink" title="Bean标签属性："></a>Bean标签属性：</h2></li>
<li><p>id：给对象在<strong>容器中</strong>提供一个唯一标识。用于获取对象。</p>
</li>
<li><p>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</p>
</li>
<li><p>scope：指定对象的作用范围。   </p>
<ul>
<li>singleton：默认值，单例的（在整个容器中只有一个对象）.</li>
<li>prototype：多例的.</li>
<li>reques：WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</li>
<li>session：WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</li>
<li>global session：WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.</li>
<li>init-method：指定类中的初始化方法名称。</li>
<li>destroy-method：指定类中销毁方法名称。比如DataSource的配置中一般需要指定destroy-method=“close”。<h2 id="Bean的作用范围："><a href="#Bean的作用范围：" class="headerlink" title="Bean的作用范围："></a>Bean的作用范围：</h2></li>
</ul>
</li>
</ul>
<ol>
<li><p>单例对象：scope=”singleton”</p>
<pre><code>* 一个应用只有一个对象的实例。它的作用范围就是整个引用。
* 生命周期：
  对象创建：当应用加载，创建容器时，对象就被创建了。
  对象活着：只要容器在，对象一直活着。
  对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</code></pre>
</li>
<li><p>多例对象：scope=”prototype”</p>
<ul>
<li>每次访问对象时，都会重新创建对象实例。</li>
<li>生命周期：<br>对象创建：当使用对象时，创建新的对象实例。<br>对象活着：只要对象在使用中，就一直活着。<br>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Singleton作用域"><a href="#Singleton作用域" class="headerlink" title="Singleton作用域"></a>Singleton作用域</h3><ul>
<li><pre><code>   ***example.xml***</code></pre>
</li>
</ul>
<blockquote>
<p>单例模式， <em>Spring IoC</em> 容器中只会存在一个共享的 <em>Bean</em> 实例，无论有多少个 <em>Bean *引用它，始终指向同一对象。 *Singleton</em> 作用域是 <em>Spring</em> 中的缺省作用域，也可以显示的将 <em>Bean</em> 定义为 <em>singleton</em> 模式，</p>
<blockquote>
<p>示例中 <em>bean</em> 只被实例化了一次，也就是只有一个 <em>bean</em> 以引用的方式分别注入<em>otherBean1</em>, <em>otherBean2</em>, <em>otherBean3</em>.</p>
</blockquote>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;otherBean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;???&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;parameterBean&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean&quot;</span>/ &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;otherBean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;???&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;parameterBean&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean&quot;</span>/ &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;otherBean3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;???&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;parameterBean&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean&quot;</span>/ &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<!--more-->

<h3 id="Prototype作用域"><a href="#Prototype作用域" class="headerlink" title="Prototype作用域"></a>Prototype作用域</h3><blockquote>
<p>   原型模式，每次通过 <em>Spring</em> 容器获取 <em>prototype</em> 定义的 <em>bean</em> 时，容器都将创建一个新的 <em>Bean</em> 实例，每个<em>Bean</em> 实例都有自己的属性和状态，而 <em>singleton</em> 全局只有一个对象。根据经验，对有状态的 <em>bean</em> 使用 <em>prototype</em> 作用域，而对无状态的 <em>bean</em> 使用 <em>singleton</em> 作用域。</p>
</blockquote>
<h3 id="Singleton-与-Prototype-混合："><a href="#Singleton-与-Prototype-混合：" class="headerlink" title="Singleton 与  Prototype 混合："></a><em>Singleton</em> 与  <em>Prototype</em> 混合：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">ref</span>&quot;<span class="attr">bean2</span>&quot;/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://image.sun1999.top/%E6%B7%B7%E5%90%88%E4%B8%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.PNG" alt="混合下的作用域"></p>
<hr>
<h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean2&quot;</span> <span class="attr">scpoe</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean1&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">ref</span>&quot;<span class="attr">bean2</span>&quot;/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    这里Bean1是 singleton,Bean2是 prototype,Bean1依赖Ban2。我们希望每次调用Bean1的某个方法时,该方法拿到的Bean2都是一个新的实例，而不是都为单实例</p>
<p>​    首先将 Bean1 中的 get 与 set 方法删除（即去掉私有属性域中的 bean2 ），改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Bean2 <span class="title">createBean2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    并将 <strong>.xml</strong> 改为即可实现方法注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean2&quot;</span> <span class="attr">scpoe</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean1&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;createBean2&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;bean2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Web环境作用域"><a href="#Web环境作用域" class="headerlink" title="Web环境作用域"></a>Web环境作用域</h2><ul>
<li>request作用域</li>
<li>session作用域</li>
<li>application作用域</li>
<li>websocket作用域</li>
</ul>
<h2 id="自定义作用域"><a href="#自定义作用域" class="headerlink" title="自定义作用域"></a>自定义作用域</h2><ul>
<li>SimpleThreadScope作用域</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Bean</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的装配(一)</title>
    <url>/archives/63714.html</url>
    <content><![CDATA[<h2 id="Autowiring-自动装配"><a href="#Autowiring-自动装配" class="headerlink" title="Autowiring(自动装配)"></a>Autowiring(自动装配)</h2><ul>
<li>**No（default）:**不做任何操作</li>
<li>**byName:**根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的 bean，并将其与属性自动装配</li>
<li>**byType(@Autowired注解就为该属性):**如果容器中存在一个与指定属性类型相同的 bean，那么将与该属性自动装配；如果存在多个该类型bean，那么抛出异常，并指出不能使用 byType 方式进行自动装配；如果没有找到相匹配的bean，则什么事都不发生</li>
<li>**constructor:**与 byType 方式类似，不同之处在于它应用于构造器参数。如果容器中没有找到与构造器参数类型一致的 bean，那么抛出异常</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                 http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       			<span class="attr">default-autowire</span>=<span class="string">&quot;no/byName/byType/constructor&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!---------------配置上面这个default-autowire属性即可-----------------&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h2 id="Resources-针对于资源文件的统一接口"><a href="#Resources-针对于资源文件的统一接口" class="headerlink" title="Resources(针对于资源文件的统一接口)"></a>Resources(针对于资源文件的统一接口)</h2><ul>
<li><p>Resources分类</p>
<ul>
<li>UrlResource:URL对应的资源，根据一个URL地址即可构建</li>
<li>ClassPathResource:获取类路径下的资源文件</li>
<li>FileSystemResource:获取文件系统里面的资源</li>
<li>ServletContextResource:ServletContext封装的资源，用于访问ServletContext环境下的资源</li>
<li>InputStreamResource:针对于输入流封装的资源</li>
<li>ByteArrayResource:针对于字节数组封装的资源</li>
</ul>
</li>
<li><p><strong>ResourceLoader接口（用于加载Resource）</strong></p>
<blockquote>
<p>All application contexts implement the ResourceLoader interface,and therefore all application contexts may be used to obtain Resource instances.</p>
<p>所有的 <strong>application contexts</strong> 都实现了 ResourceLoader 接口<br>也就是说，所有的 application contexts 都可以用来获取 Resource 实例</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ResourceLoader接口的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span></span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个路径依赖于 application contexts 的路径</span></span><br><span class="line">Resource template = ctx.getResource(<span class="string">&quot;some/resource/path/myTemplate.txt&quot;</span>)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这一个是作为URL加载</span></span><br><span class="line">Resource template = ctx.getResource(<span class="string">&quot;file:/some/resource/path/myTemplate.txt&quot;</span>)；</span><br><span class="line"></span><br><span class="line">Resource template = ctx.getResource(<span class="string">&quot;classpath:some/resource/path/myTemplate.txt&quot;</span>) </span><br><span class="line">Resource template = ctx.getResource(<span class="string">&quot;http://webpath/myTemplate.txt&quot;</span>) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的装配(二)</title>
    <url>/archives/14406.html</url>
    <content><![CDATA[<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>此注解可以用在Bean的成员变量，setter()方法与构造器上。</li>
</ul>
<hr>
<ul>
<li>默认情况下 (required=true)，如果因找不到合适的bean将会导致 autowiring 失败抛出异常，可以通过下面的方式避免：</li>
</ul>
<blockquote>
<p>此成员变量在使用时为 null 值，在这种情况下使用此Bean中的此成员变量时，需要判定其是否为 null ，否则容易出现空指针异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovielister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autovired(required=false)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>,movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个类只能有一个<strong>构造器</strong>被标记为required=true</li>
<li><code>initMethod</code>属性定义初始化前方法，类似于 @PostConstruct</li>
<li><code>destroyMethod</code>属性定义销毁前方法，类似于 @PreDestory</li>
<li>@Autovired(required=true)，建议使用@Required注解代替</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="默认可解析的接口"><a href="#默认可解析的接口" class="headerlink" title="默认可解析的接口"></a>默认可解析的接口</h3><ul>
<li><p>可以使用@Autowired注解那些众所周知的解析依赖性接口，比如：</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
<li>Environment</li>
<li>ResourceLoader</li>
<li>ApplicationEventPublisher</li>
<li>MessageSource</li>
</ul>
</li>
<li><p>第二点的意思是，可以在Bean中声明以上接口的引用，再在变量上添加注解，这样这些引用就可以被Spring自动装配</p>
</li>
</ul>
<hr>
<h3 id="装配集合变量"><a href="#装配集合变量" class="headerlink" title="装配集合变量"></a>装配集合变量</h3><ul>
<li>可以通过添加注解给需要该类型的数组的字段或方法，以提供 ApplicationContext 中的所有特定类型的 bean</li>
</ul>
<blockquote>
<p>例子中 Spring 会加载当前 ApplicationContext 中所有的 Type 为 泛型类型 (MovieCatalog) 的 bean ，及其子类自动装配入 Set (movieCatalogs) 集合；如果泛型类型为接口，那么会自动装配其所有实现类；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Moviecatalog&gt; movieCatalogs;</span><br><span class="line"><span class="meta">@Autovired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以用于装配 Map(String 为 beanId ),List…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String,MovleCatalog&gt; movlecatalogs;</span><br><span class="line"><span class="meta">@Autovired</span></span><br><span class="line"><span class="function">publio <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String,MovieCatalog&gt; movieCatalogs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果希望数组有序，可以让 bean 实现 org.springframework.core.Ordered 接口或使用的 @Order 注解（Map无效）</p>
</li>
<li><p>注意：@Autowired 由 Spring BeanPostProcessor 处理，故不能在自定义的 BeanPostProcessor 或<br>BeanFactoryPostProcessor 类型应用这些注解，这些类型必须通过 XML 或者 Spring 的 @Bean注解加载</p>
</li>
</ul>
<hr>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><ul>
<li><p>配合@PostConstruct 定义初始化前方法，类似于 @Autowired 的<code>initMethod</code>属性 </p>
</li>
<li><p>配合@PreDestory 定义销毁前方法，类似于 @Autowired 的 <code>destroyMethod</code>属性</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxMDIxMDQvYXJ0aWNsZS9kZXRhaWxzLzc5NDgxMDA3P3V0bV9zb3VyY2U9YmxvZ3hnd3o1">以下部分为编辑后转载，点击查看原文<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>@Resource 和 @Autowired  都可以用来装配 bean，都可以用于字段或 setter 方法。</li>
<li>@Autowired默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的<code>required</code>属性为false。</li>
<li>@Resource默认按名称装配，当找不到与名称匹配的bean时才按照类型进行装配。名称可以通过name属性指定，<strong>如果没有指定name属性，当注解写在字段上时，默认取字段名；当注解写在setter方法上时，默认取属性名进行装配。</strong>（如果name属性一旦手动指定，就只会按照名称进行装配）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;cat&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Animal animal;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;cat&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Animal animal;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center">@Resource</th>
<th align="center">@Autowire</th>
</tr>
</thead>
<tbody><tr>
<td align="center">注解来源</td>
<td align="center">JDK</td>
<td align="center">Spring</td>
</tr>
<tr>
<td align="center">装配方式</td>
<td align="center">优先按 name</td>
<td align="center">优先按 type</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">name、type</td>
<td align="center">value,required</td>
</tr>
</tbody></table>
<hr>
<h2 id="Qualifier-amp-Named"><a href="#Qualifier-amp-Named" class="headerlink" title="@Qualifier    &amp;    @Named"></a>@Qualifier    &amp;    @Named</h2><ul>
<li><p><em>@Named 类似于 @Qualifier</em></p>
</li>
<li><p>按类型自动装配可能多个 bean 实例的情况，可以使用 Spring 的 @Qualifier 注解<strong>缩小范围（或指定唯一）</strong>，也可以用于<strong>指定单独的构造器参数或方法参数</strong></p>
</li>
<li><p>可用于注解集合类型变量</p>
</li>
<li><p>如果通过名字进行注解注入，主要使用的不是 @Autowired (即使在技术上能够通过@Qualifier指定bean的名字），替代方式是<strong>使用 JSR-250 @Resource 注解</strong>，它是通过其独特的名称来定义来识别特定的目标（这是一个与所声明的类型是无关的匹配过程）</p>
</li>
<li><p>因语义差异，集合或Map类型的bean无法通过@Autowired来注入，因为没有类型匹配到这样的bean，为这些bean使用@Resource注解，通过唯一名称引用集合或Map的bean</p>
</li>
</ul>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><ul>
<li>@Bean 标识一个用于配置和初始化一个由 SpringloC 容器管理的新对象的方法，类似于 XML 配置文件的 <code>&lt;bean&gt;</code></li>
<li>可以在 Spring 的  @Component 注解的类中使用 @Bean 注解任何方法(仅仅是可以）,类注解我们通常使用<code>@Configuration</code> 而不是<code>@Component </code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">publiuc <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//这里 Bean的默认name为 myService，即方法名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.services.MyserviceImpl &quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>默认 @Bean 是单例，可以搭配 @Scope(“<code>scope</code>“)</p>
<blockquote>
<p>   ‘scope’ 可以填为 singleton,prototype,request,session,global session</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Classpath扫描与组件管理</title>
    <url>/archives/42894.html</url>
    <content><![CDATA[<p>从 Spring3.0开始，Spring JavaConfig 项目提供了很多特性，包括使用 java 而不是 XML 定义 bean .</p>
<p><strong>比如</strong>：</p>
<ul>
<li>@Configuration,@Bean,@Import,@DependsOn</li>
<li>@Component是一个通用注解，可用于任何bean</li>
<li>@Repository,@Service,@Controller是更有针对性的注解<ul>
<li>@Repository通常用于注解DAO类，即持久层</li>
<li>@Service通常用于注解Service类，即服务层</li>
<li>@Controller通常用于Controller类，即控制层（MVC）  <a id="more"></a>

</li>
</ul>
</li>
</ul>
<h2 id="类的自动检测及Bean的注册"><a href="#类的自动检测及Bean的注册" class="headerlink" title="类的自动检测及Bean的注册"></a>类的自动检测及Bean的注册</h2><p>为了能够检测这些类并注册相应的Bean，需要下面内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 注解扫描dao和service类 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 该组件扫描器，会去扫描@Component、@Controller(表现层)、@Service(业务层)、@Repository(持久层)、@RestController --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kkb.project&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>   context:component-scan 包含c ontext:annotation-config ，通常在使用前者后，不用再使用后者</li>
<li>   AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor也会被包含进来</li>
</ul>
<h2 id="使用过滤器进行自定义扫描"><a href="#使用过滤器进行自定义扫描" class="headerlink" title="使用过滤器进行自定义扫描"></a>使用过滤器进行自定义扫描</h2><ul>
<li>默认情况下，类被自动发现并注册bean的条件是：使用@Component,@Repository,@Service,@Controller注解或者使用@Component的自定义注解<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vb25seW1hdGUvcC83ODAyMTIyLmh0bWw=">Spring – context:component-scan使用说明<i class="fa fa-external-link-alt"></i></span><br>上面这篇文章写的很详细，可供参考</p>
</blockquote>
</li>
</ul>
<h2 id="作用域-Scpoe"><a href="#作用域-Scpoe" class="headerlink" title="作用域(Scpoe)"></a>作用域(Scpoe)</h2><ul>
<li>通常情况下自动查找的Spring组件，其scope是singleton，Spring2.5提供了一个标识scope的注解@Scope</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class MovieFinderImpl implements <span class="title">MovieFinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以自定义scope策略，实现ScopeMetadataResolver接口并提供一个无参构造器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-acan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">scope-resolver</span>=<span class="string">&quot;org.example.MyScopeResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a>代理方式</h2><ul>
<li>   可以使用scoped-proxy属性指定代理，有三个值可选：no(default),interfaces,targetClass<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>	<span class="attr">gcoped-proxy</span>=<span class="string">&quot;intexfaces&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaBean的实例化与注入方式</title>
    <url>/archives/2794.html</url>
    <content><![CDATA[<h2 id="实例化Bean的方式"><a href="#实例化Bean的方式" class="headerlink" title="实例化Bean的方式"></a>实例化Bean的方式</h2><h3 id="spring-xml-样例"><a href="#spring-xml-样例" class="headerlink" title="spring.xml    样例"></a>spring.xml    样例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                 http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过构造方法实例化Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.?.Bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过静态方法实例化Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFromFactory1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.BeanFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createBean1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过实例方法实例化Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.BeanFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFromFactory2&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createBean2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Bean的别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bean2, bean3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.Bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;bean4&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<hr>
<h2 id="Spring-DI-依赖注入"><a href="#Spring-DI-依赖注入" class="headerlink" title="Spring DI(依赖注入)"></a>Spring DI(依赖注入)</h2><h3 id="spring-xml-样例-1"><a href="#spring-xml-样例-1" class="headerlink" title="spring.xml    样例"></a>spring.xml    样例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用&quot;c:&quot;.&quot;p:&quot;需要引入&quot;xmlns:c&quot;与&quot;xmlns:p&quot;,这两个链接访问不到，但是可以正常使用，很不解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                 http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过构造方法注入Bean，&quot;c:&quot;为简便写法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diByConstructor1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIByConstructor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一般来说index或name就可以唯一确定，所以两者中只用写一个，而type可以省略--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- index:构造函数中参数的位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- type:参数类名，基本类型填包装类--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name:type填写的Bean的构造函数中的参数的名字--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- value:常用类型填值--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ref:自定义类型填值，这里的值为所填type类Bean的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">name</span>=<span class="string">&quot;anotherBean&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">type</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;stringValue&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">value</span>=<span class="string">&quot;aaaa&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;integerValue&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">value</span>=<span class="string">&quot;1111&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diByConstructor2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIByConstructor&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:anotherBean-ref</span>=<span class="string">&quot;anotherBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:stringValue</span>=<span class="string">&quot;aaaa&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:integerValue</span>=<span class="string">&quot;1111&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过set方法注入Bean，&quot;p:&quot;为简便写法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diBySetter1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIBySetter&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name:Bean中变量名--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- value:常用类型填值--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ref:自定义类型填值，这里的值为所填type类Bean的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stringValue&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaaa&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;integerValue&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1111&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diBySetter2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIBySetter&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:anotherBean-ref</span>=<span class="string">&quot;anotherBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:stringValue</span>=<span class="string">&quot;aaaa&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:integerValue</span>=<span class="string">&quot;1111&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean5&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean6&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean7&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diByCollection&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIByCollection&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- list --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stringList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaaaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbbbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;anotherBeanList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherBean1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherBean2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- set --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stringSet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ddddd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;anotherBeanSet&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherBean3&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherBean4&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- map --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stringMap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;eeeee&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fffff&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ggggg&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hhhhh&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;anotherBeanMap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">&quot;anotherBean5&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;anotherBean6&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">&quot;anotherBean7&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;anotherBean8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- priperties --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;hhhhh&quot;</span> <span class="attr">value</span>=<span class="string">&quot;iiiii&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;jjjjj&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kkkkk&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- null --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diByNull&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIByNull&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;anotherBean&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- InnerClass --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diByInnerClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.***.DIByInnerClass&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;anotherBean&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 内部创建一个Bean，就不需要外部创建Bean再通过id来获取，在XML结构上可以看作高级语言中的局部变量 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.***.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中AspectJ的XML开发</title>
    <url>/archives/38488.html</url>
    <content><![CDATA[<ul>
<li>schema-defined aspects只支持singleton model，即：所有基于配置文件的切面只支持单例模式</li>
<li>Spring所有的切面和通知器都必须放在一个<code>&lt;aop:config&gt;</code>内（可以配置包含多个<code>&lt;aop:config&gt;</code>元素），每一个<code>&lt;aop:config&gt;</code>可以包含<code>pointcut</code>，<code>advisor</code>和<code>aspect</code>元素(必须按照以上顺序进行声明）</li>
<li><code>&lt;aop:config&gt;</code>风格的配置大量使用了Spring的自动代理机制<a id="more"></a>

</li>
</ul>
<h2 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.MyAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.MyBiz&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBiz&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspectAOP&quot;</span>&gt;</span></span><br><span class="line">			···</span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="切入点-Pointcut"><a href="#切入点-Pointcut" class="headerlink" title="切入点(Pointcut)"></a>切入点(Pointcut)</h2><p>首先，介绍这里使用的一些基本通配符的含义</p>
<ul>
<li><p>* ： 匹配任意数量的字符</p>
</li>
<li><p>+ ：匹配制定数量的类及其子类</p>
</li>
<li><p>.. ：匹配本包</p>
</li>
<li><p>… ：匹配本包及其子包</p>
<hr>
</li>
</ul>
<ul>
<li>execution(权限类型)</li>
<li>execution(public* *(..)) <pre><code>                                                切入点为执行所有public方法时</code></pre>
</li>
<li>execution(* set*(..))<pre><code>                                                切入点为执行所有set开始的方法时</code></pre>
</li>
<li>execution(* com.xyz.service.AccountService.*(..))<pre><code>                                                切入点为执行AccountService类中的所有方法时</code></pre>
</li>
<li>execution(* com.xyz.service..(..)) <pre><code>                                                切入点为执行com.xyz.service包下的所有方法时</code></pre>
</li>
<li>execution(* com.xyz.service…(..))<pre><code>                                                切入点为执行com.xyz.service包及其子包下的所有方法时</code></pre>
</li>
</ul>
<p>以下，Only in Spring AOP</p>
<ul>
<li>within(com.xyz.service.*)</li>
<li>within(com.xyz.service..*)<pre><code>                                                within 用于匹配指定类型内的方法执行</code></pre>
</li>
<li>this(com.xyz.service.AccountService)<pre><code>                                                this 用于匹配当前AOP代理对象类型的执行方法</code></pre>
</li>
<li>target(com.xyz.service.AccountService)<pre><code>                                                target用于匹配当前目标对象类型的执行方法</code></pre>
</li>
<li>args(java.io.Serializable)<pre><code>                                                args用于匹配当前执行的方法传入的参数为指定类型的执行方法</code></pre>
</li>
<li>@target(org.springframework.transaction.annotation.Transactional)</li>
<li>@within(org.springframework.transaction.annotation.Transactional)</li>
<li>@annotation(org.springframework.transaction.annotation.Transactional)</li>
<li>@args(com.xyz.security.Classified)</li>
<li>bean(tradeService)</li>
<li>bean(*Service)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.MyAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.MyBiz&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBiz&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspectAOP&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知（Before advice)</td>
<td>在某连接点（join point）之前执行的通知，但不能阻止连接点前的执行（除非它抛出一个异常)</td>
</tr>
<tr>
<td>返回后通知(After returning advice)</td>
<td>在某连接点（join point）完成后执行的通知（不论是正常返回还是异常退出)</td>
</tr>
<tr>
<td>抛出异常后通知(After throwing advice)</td>
<td>在方法抛出异常退出时执行的通知</td>
</tr>
<tr>
<td>后通知(After(finally)advice)</td>
<td>当某连接点退出的时候执行的通知</td>
</tr>
<tr>
<td>环绕通知(Around Advice)</td>
<td>包围一个连接点（join point）的通知</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//@Before</span></span><br><span class="line">    result = method.invoke(target, args);</span><br><span class="line">    <span class="comment">//@After</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    Throwable targetException = e.getTargetException();</span><br><span class="line">    <span class="comment">//@AfterThrowing</span></span><br><span class="line">    <span class="keyword">throw</span> targetException;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//@AfterReturning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.MyAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.MyBiz&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBiz&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下两种配置方式等效--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--------1-------&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspectAOP&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--------2--------&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span></span></span><br><span class="line"><span class="tag">                        			<span class="attr">pointcut</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span></span></span><br><span class="line"><span class="tag">                       				<span class="attr">pointcut</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span></span></span><br><span class="line"><span class="tag">                               		 <span class="attr">pointcut</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span></span></span><br><span class="line"><span class="tag">                                 	 <span class="attr">pointcut</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">&lt;!-----------------&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Around advice</p>
<ul>
<li><p>通知方法的第一个参数必须是<code>ProceedingJoinPoint</code>类型</p>
</li>
<li><p>.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAspectAOP&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* aop.schema.MyBiz.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span>.</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>  .java</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h2 id="测试所用代码"><a href="#测试所用代码" class="headerlink" title="测试所用代码"></a>测试所用代码</h2><ul>
<li><p>业务对象<code>MyBiz2</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> aop.schema.around;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBiz2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">biz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBiz：biz()&quot;</span>);</span><br><span class="line"><span class="comment">//        throw new RuntimeException();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String bizName, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBiz：init()&quot;</span> + <span class="string">&quot; bizName:&quot;</span> + bizName + <span class="string">&quot; times:&quot;</span> + times);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>切面对象<code>MyParametersAdvice</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> aop.schema.around;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParametersAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp, String bizName, <span class="keyword">int</span> times)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice：around()&quot;</span> + <span class="string">&quot; bizName:&quot;</span> + bizName + <span class="string">&quot; times:&quot;</span> + times);</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice: around() FirstPrint&quot;</span>);</span><br><span class="line">        Object obj = pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice: around() SecondPrint&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice:before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice:afterReturning()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice:afterThrowing()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParametersAdvice:after()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Spring配置文件 <code>schema-around.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myParametersAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.around.MyParametersAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBiz2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.schema.around.MyBiz2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myParametersAdviceAOP&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myParametersAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* aop.schema.around.MyBiz2.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">pointcut</span>=<span class="string">&quot;execution(* aop.schema.around.MyBiz2.init(String,int)) and args(bizName,times)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试类<code>parametersAdviceTest</code> 其继承的<code>UnitTestBase</code>在 <span class="exturl" data-url="aHR0cHM6Ly9zdW4xOTk5LnRvcC8yMDE5L1NwcmluZyVFNCVCOCVBRCVFNCVCRCVCRiVFNyU5NCVBOEpVbml0NCVFNyU5QSU4NCVFOCVCRiU4NyVFNSVCQSVBNiVFNiU5NiVCOSVFNiVCMyU5NS8=">Spring中使用JUnit4的过度方法<i class="fa fa-external-link-alt"></i></span> 中给出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AOP.around;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aop.schema.around.MyBiz2;</span><br><span class="line"><span class="keyword">import</span> beans.UnitTestBase;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(BlockJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">parametersAdviceTest</span> <span class="keyword">extends</span> <span class="title">UnitTestBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">parametersAdviceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;AOP/schema-around.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyBiz2 myBiz2 = <span class="keyword">super</span>.getBean(<span class="string">&quot;myBiz2&quot;</span>);</span><br><span class="line">        myBiz2.biz();</span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">        myBiz2.init(<span class="string">&quot;testString&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制台输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyParametersAdvice:before()</span><br><span class="line">MyBiz：biz()</span><br><span class="line">MyParametersAdvice:after()</span><br><span class="line">MyParametersAdvice:afterReturning()</span><br><span class="line">*******************</span><br><span class="line">MyParametersAdvice:before()</span><br><span class="line">MyParametersAdvice：around() bizName:testString times:2</span><br><span class="line">MyParametersAdvice: around() FirstPrint</span><br><span class="line">MyBiz：init() bizName:testString times:2</span><br><span class="line">MyParametersAdvice: around() SecondPrint</span><br><span class="line">MyParametersAdvice:after()</span><br><span class="line">MyParametersAdvice:afterReturning()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>Schema</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中AspectJ的注解开发</title>
    <url>/archives/19592.html</url>
    <content><![CDATA[<blockquote>
<p>@AspectJ注解于类名上来声明这个类是一个切面类</p>
</blockquote>
<h2 id="AspectJ-简介"><a href="#AspectJ-简介" class="headerlink" title="AspectJ 简介"></a>AspectJ 简介</h2><ul>
<li>AspectJ是一个基于Java语言的AOP框架</li>
<li>Spring2.0以后新增了对AspectJ切点表达式支持</li>
<li>@AspectJ 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面</li>
<li>新版本Spring框架，建议使用AspectJ方式来开发AOP</li>
<li>使用AspectJ 需要导入Spring AOP和 AspectJ相关jar包<ul>
<li>spring-aop-4.2.4.RELEASE.jar</li>
<li>com.springsource.org.aopalliance-1.0.0.jar</li>
<li>spring-aspects-4.2.4.RELEASE.jar</li>
<li>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar<a id="more"></a>
<h2 id="xml头配置"><a href="#xml头配置" class="headerlink" title=".xml头配置"></a>.xml头配置</h2></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启AspectJ的注解开发，自动代理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="切入点表达式部分关键词"><a href="#切入点表达式部分关键词" class="headerlink" title="切入点表达式部分关键词"></a>切入点表达式部分关键词</h2><ol>
<li><p>execution：用于匹配子表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.cjm.model包及其子包中所有类中的所有方法，返回类型任意，方法参数任意</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.cjm.model..*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>within：用于匹配连接点所在的Java类或者包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配Person类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.cjm.model.Person)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//匹配com.cjm包及其子包中所有类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.cjm..*)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this：用于向通知方法中传入代理对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;before() &amp;&amp; this(proxy)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point, Object proxy)</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>target：用于向通知方法中传入目标对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;before() &amp;&amp; target(target)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point, Object proxy)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>args：用于将参数传入到通知方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;before() &amp;&amp; args(age,username)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point, <span class="keyword">int</span> age, String username)</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AspectJ的不同通知类型"><a href="#AspectJ的不同通知类型" class="headerlink" title="@AspectJ的不同通知类型"></a>@AspectJ的不同通知类型</h2></li>
</ol>
<ul>
<li><p>所有通知的<code>value</code>属性都是<code>Pointcut</code>，可以直接写表达式，也可以写成一个被<code>@Pointcut</code>注解过的方法，类似于下面的例字</p>
<ul>
<li>顺带介绍<code>@Pointcut</code>注解的格式：<code>private void 无参数方法，方法名为切点名</code>，且当通知多个切点时，可以使用|| 进行连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.xyz.aspectJ.ProductDao.save(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before(value = &quot;aPointcut1()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------等效于----------------</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(* com.xyz.aspectJ.ProductDao.save(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Before 前置通知，相当于BeforeAdvice</p>
<p>可以在<code>before()</code>方法中添加 <code>JoinPoint joinPoint</code>，<strong>这样就可以在切面方法中获得切入点信息</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;myPointcut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@AfterReturning 后置通知，相当于AfterReturningAdvice</p>
<ul>
<li>若目标方法有返回值，就需要给<code>@AfterReturning</code>注释中的 <code>returning</code>属性赋值，方法添加一个<code>Object returnObj</code>参数，<strong>这样可以在切面方法中获得目标方法的返回值</strong></li>
<li>这里<code>returning = &quot;returnObj&quot;</code>中 <code>&quot;returnObj&quot;</code> 字符串的值可以任取，但要保证函数中传入的参数名与之相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;myPointcut()&quot;, returning = &quot;returnObj&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturing</span><span class="params">(Object returnObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Around 环绕通知，相当于MethodInterceptor</p>
<ul>
<li>切面方法的返回值就是代理方法执行返回值，一般将返回值写为<code>Object</code></li>
</ul>
</li>
<li><p>参数必须包含<code>ProceedingJoinPoint</code>，它的作用是调用拦截目标方法执行</p>
<ul>
<li><strong>如果不调用 <code>ProceedingJoinPoint</code>的<code>proceed</code>方法，那么目标方法就不会被执行</strong></li>
</ul>
</li>
<li><p>ProceedingJoinPoint 对象的 proceed() 需要捕获异常，并且这里如果产生异常（即目标方法产生异常）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(value = &quot;myPointcut3()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething	假设这里开启事务</span></span><br><span class="line">    Object obj = joinPoint.proceed(); <span class="comment">// 执行目标方法	假设为数据库的操作</span></span><br><span class="line">    <span class="comment">//doSomething	假设这里提交事务</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@AfterThrowing异常抛出通知，相当于ThrowAdvice</p>
<p>这里的<code>throwing</code>属性使用方法与<code>@AfterReturning</code>注释中的 <code>returning</code>属性类似，可以让代理方法得到目标方法所抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@AfterThrowing(value = &quot;myPointcut4()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//doSomething 假设回滚事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@After 最终final通知，不管是否异常，该通知都会执行</p>
</li>
<li><p>@DeclareParents 引介通知，相当于IntroductionInterceptor</p>
</li>
</ul>
<h2 id="通过Value属性定义切点（execution函数）"><a href="#通过Value属性定义切点（execution函数）" class="headerlink" title="通过Value属性定义切点（execution函数）"></a>通过Value属性定义切点（execution函数）</h2><p>​        <em>在通知中通过value属性定义切点，通过execution函数，可以定义切点的方法切入</em></p>
<p><strong>1. 语法：</strong></p>
<p>​        <code>execution(&lt;访问修饰符&gt;? &lt;返回类型&gt; &lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</code></p>
<p><strong>2. 介绍这里使用的一些基本通配符的含义:</strong></p>
<ul>
<li><code>*</code> 匹配任意数量的字符</li>
<li><code>+</code>匹配制定数量的类及其子类，可用于表示实现此接口的所有类</li>
<li><code>..</code>  匹配本包及其子包</li>
<li><code>&amp;&amp;、||、!</code> 切入点表达式支持逻辑运算符</li>
</ul>
<p><strong>3. 例:</strong></p>
<ul>
<li><p>匹配所有类public方法</p>
<p>​    <code>execution(public * *(..))</code></p>
</li>
<li><p>匹配指定包下所有类方法 </p>
<ul>
<li><code>execution(* com.imooc.dao.*(..))</code>      不包含子包</li>
<li><code>execution(* com.imooc.dao..*(..))</code>    <code>..*</code>表示包、子孙包下所有类</li>
</ul>
</li>
<li><p>匹配指定类所有方法</p>
<p>​    <code>execution(* com.imooc.service.UserService.*(..))</code></p>
</li>
<li><p>匹配实现特定接口所有类方法</p>
<p>​    <code>execution(* com.imooc.dao.GenericDAO+.*(..))</code></p>
</li>
<li><p>匹配所有save开头的方法</p>
<p>​    <code>execution(* save*(..))</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>AspectJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中使用JUnit4的过度方法</title>
    <url>/archives/48524.html</url>
    <content><![CDATA[<blockquote>
<p>肯定有整合过的单元测试组件用，spring不会有这么不优雅的东西，只是我还不会，暂时凑合着先用    ORZ</p>
</blockquote>
<ul>
<li><p>创建UnitTestBase类（放在Test目录好看点），完成对Spring配置文件的加载、销毁所有的单元测试类都继承自UnitTestBase，通过它的getBean方法获取想要得到的对象</p>
</li>
<li><p>子类（具体执行单元测试的类）加注解：</p>
<p>@RunWith(BlockJUnit4ClassRunner.class)</p>
</li>
<li><p>单元测试方法加注解：@Test</p>
</li>
<li><p>右键选择要执行的单元测试方法执行或者执行一个类的全部单元测试方法</p>
</li>
</ul>
<h2 id="UnitTestBase工具类"><a href="#UnitTestBase工具类" class="headerlink" title="UnitTestBase工具类"></a>UnitTestBase工具类</h2><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.***;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTestBase</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ClassPathXmlApplicationContext context;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String springXmlpath;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnitTestBase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnitTestBase</span><span class="params">(String springXmlpath)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.springXmlpath = springXmlpath;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isEmpty(springXmlpath)) &#123;</span><br><span class="line">			springXmlpath = <span class="string">&quot;classpath*:spring-*.xml&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			context = <span class="keyword">new</span> ClassPathXmlApplicationContext(springXmlpath.split(<span class="string">&quot;[,\\s]+&quot;</span>));</span><br><span class="line">			context.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@After</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		context.destroy();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">protected</span> &lt;T extends Object&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (T)context.getBean(beanId);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> &lt;T extends Object&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>单元测试</tag>
        <tag>JUnit4</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring对JSR-330的支持</title>
    <url>/archives/27107.html</url>
    <content><![CDATA[<ul>
<li><p>从Spring3.0开始支持JSR330标准注解（依赖注入注解），其扫描方式与Spring注解一致</p>
</li>
<li><p>Spring自带的<code>@Autowired</code>的缺省情况等价于JSR-330的<code>@Inject</code>注解；</p>
</li>
<li><p>Spring自带的<code>@Qualifier</code>的缺省的根据Bean名字注入情况等价于JSR-330的<code>@Named</code>注解； </p>
</li>
<li><p>Spring自带的<code>@Qualifier</code>的扩展<code>@Qualifier</code>限定描述符注解情况等价于JSR-330的<code>@Qualifier</code>注解。</p>
<a id="more"></a></li>
<li><p>使用JSR330需要依赖javax.inject包</p>
</li>
<li><p>使用Maven引入方式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/javax.inject/javax.inject --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><strong><code>@Named</code>也可以用在类上，等价于<code>@Component</code></strong></li>
<li><code>@Named(value=&quot;&quot;)</code> 可以指定 Bean Name ， 类似于<code>@Qualifier</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsrDAO</span><span class="params">(<span class="meta">@Named(&quot;jsrDAO&quot;)</span>JsrDAO jsrDAO)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.jsrDAO=jsrDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>使用注解进行资源文件读取</title>
    <url>/archives/13500.html</url>
    <content><![CDATA[<h2 id="使用-ImportResource-和-Value-进行资源文件读取"><a href="#使用-ImportResource-和-Value-进行资源文件读取" class="headerlink" title="使用 @ImportResource 和 @Value 进行资源文件读取"></a>使用 @ImportResource 和 @Value 进行资源文件读取</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">db.url</span> = <span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">db.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span> = <span class="string">pwword</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：读取<code>properties</code>文件中的数据时，若所在系统环境中有重名的环境变量与<code>properties</code>中<code>key</code>值相同，那么其值会被系统变量中的值所覆盖，这样会导致错误，所以我们一般将  本为<code>url</code>的<code>key</code>改写为<code>db.url</code>，即加上特殊前缀，以防止重命冲突情况的发生。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String url;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Value(&quot;$&#123;jdbc,username&#125;&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Value(&quot;$&#123;jdbc.passvord&#125;&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url,username,pasaword);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>类似于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.***&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.AppConfig&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc,ur1)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>通过AOP为特定的类引入新的功能</title>
    <url>/archives/39847.html</url>
    <content><![CDATA[<blockquote>
<p>如果有这样一个需求，<strong>为一个已知的API添加一个新的功能</strong>。</p>
<p>由于是已知的API，我们不能修改其类，只能通过外部包装。但是如果通过之前的AOP前置或后置通知，又不太合理，最简单的办法就是实现某个我们自定义的接口，这个接口包含了想要添加的方法。</p>
<p>但是Java不是一门动态的语言，无法再编译后动态添加新的功能，这个时候就可以使用<code> &lt;aop:declare-parents&gt;</code> 来做了。</p>
</blockquote>
<a id="more"></a>

<p>如果是可以改写的类，直接实现自定义的接口就行了，下面看看AOP是如何做的！</p>
<ul>
<li>最开始使用的类和接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.test.declareparents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Chinese</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiLei</span> <span class="keyword">implements</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是中国人！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>   想要添加的新功能和接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.test.declareparents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Todo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoSomething</span> <span class="keyword">implements</span> <span class="title">Add</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Todo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱中国！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过配置AOP，实现两种功能的耦合</p>
<blockquote>
<p><code>types-mathcing</code>是之前原始的类</p>
<p><code>implement-interface</code>是想要添加的功能的接口</p>
<p><code>default-impl</code>是新功能的默认的实现</p>
</blockquote>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lilei&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.test.declareparents.LiLei&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;doSomething&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.test.declareparents.DoSomething&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:declare-parents</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">types-matching</span>=<span class="string">&quot;com.spring.test.declareparents.LiLei&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">implement-interface</span>=<span class="string">&quot;com.spring.test.declareparents.Add&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">default-impl</span>=<span class="string">&quot;com.spring.test.declareparents.DoSomething&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在使用时，直接通过<code>getBean</code>获得bean转换成相应的接口就可以使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Chinese lilei = (Chinese)ctx.getBean(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">lilei.Say();</span><br><span class="line"></span><br><span class="line">Add lilei2 = (Add)ctx.getBean(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">lilei2.Todo();</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>作者：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS94aW5nOTAxMDIy">xingoo<i class="fa fa-external-link-alt"></i></span><br>本文转载于：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGluZzkwMTAyMi9wLzQyNjU3NDguaHRtbA==">https://www.cnblogs.com/xing901022/p/4265748.html<i class="fa fa-external-link-alt"></i></span><br>本文版权归作者和博客园共有。欢迎转载，但必须保留此段声明，且在文章页面明显位置给出原文连接！</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC模式</title>
    <url>/archives/12522.html</url>
    <content><![CDATA[<p>MVC是一种架构模式</p>
<ul>
<li>程序分层，分工合作，既相互独立，又协同工作。</li>
</ul>
<p>MVC是一种思考方式</p>
<ul>
<li>需要将什么信息展示给用户？如何布局？调用哪些业务逻辑？</li>
</ul>
<blockquote>
<p> MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<p> Model：模型层  片面说就是实体类，业务数据的信息表示，关注支撑业务的信息构成，通常是多个业务实体的组合。<br> View：视图层    为用户提供UI，重点关注数据的呈现<br> Controller：控制层 调用业务逻辑产生合适的数据(Model) 传递数据给视图层用于呈现</p>
</blockquote>
<a id="more"></a>

<p>这里提下，Front Controller（前端控制器）</p>
<p><img src="http://image.sun1999.top/20190519103339.png"></p>
<ul>
<li>可以借助下图理解前端控制器 <img src="http://image.sun1999.top/20190519103658.png"></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC基本概念</title>
    <url>/archives/15033.html</url>
    <content><![CDATA[<h3 id="各组件介绍"><a href="#各组件介绍" class="headerlink" title="各组件介绍"></a>各组件介绍</h3><ul>
<li><p>DispatcherServlet：</p>
<ul>
<li>作为MVC前端控制器</li>
</ul>
</li>
<li><p>Handler：</p>
<ul>
<li>DispatcherServlet调用Controller层的中间过度对象<blockquote>
<p>DispatcherServlet内部使用的一个类，是Controller的一个表现形式，SpringMVC没有Controller的接口，DispatcherServlet中调用的Controller是以Handler形式出现的</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HandlerAdapter：</p>
<ul>
<li>Handler适配器</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>HandlerAdapterInterceptor：<ul>
<li>Controller/Handler拦截器，在被拦截的对象执行前后执行一些操作，算是AOP思想</li>
</ul>
</li>
<li>HandlerMapping：<ul>
<li>DispatcherServlet中Handler与Controller的映射关系的一种类</li>
<li>告诉DispatcherServlet一个请求到来之后，调用哪个Controller来相应此请求</li>
<li>返回包裹了HandlerAdapterInterceptor与Controller实例的HandlerAdapter对象，它们会构成一个链条往下走</li>
</ul>
</li>
<li>HandlerExecutionChain：</li>
<li>preHandle –&gt; Controller.someMethod –&gt; postHandle –&gt; afterCompletion</li>
<li>ModelAndView：</li>
<li>SpringMVC中一种对Model的具体表现形式<ul>
<li>DispatcherServlet 会将Model与Map都转换为ModelAndView</li>
</ul>
</li>
<li>ViewResolver：视图解析器</li>
<li>根据配置帮助DispatcherServlet找出需要的视图对象，比如jsp</li>
<li>View：<ul>
<li>负责页面的呈现</li>
</ul>
</li>
</ul>
<h3 id="简单框架图"><a href="#简单框架图" class="headerlink" title="简单框架图"></a>简单框架图</h3><p><img src="http://image.sun1999.top/20190519121847.png"></p>
<h3 id="详细框架图"><a href="#详细框架图" class="headerlink" title="详细框架图"></a>详细框架图</h3><p><img src="http://image.sun1999.top/20190519122059.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是P问题、NP问题和NPC问题</title>
    <url>/archives/10695.html</url>
    <content><![CDATA[<p> 这或许是众多OIer最大的误区之一。</p>
<p> 你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。</p>
<a id="more"></a>

<p> 还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。不会存在O(2*n^2)的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，O (n^3+n^2)的复杂度也就是O(n^3)的复杂度。因此，我们会说，一个O(0.01*n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度。</p>
<p> 容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p>
<p> 自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。<span class="exturl" data-url="aHR0cDovL3d3dy5tYXRyaXg2Ny5jb20vYmxvZy9hcnRpY2xlLmFzcD9pZD02Mg==">The Halting Problem<i class="fa fa-external-link-alt"></i></span>就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题</p>
<p> 下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p>
<p> 接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。</p>
<p> 之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p>
<p> 很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。</p>
<p> NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。</p>
<p> 目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p>
<p> 为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。</p>
<p> 简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p>
<p> “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p>
<p> 很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。</p>
<p> 现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。</p>
<p> 当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<p> 好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p>
<p> NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p>
<p> 既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<p> 顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p>
<p> 不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。</p>
<p> 下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p>
<p> 逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。</p>
<p> 什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br><img src="http://image.sun1999.top/20210213231708.png"><br> 这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。<br> 有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br><img src="http://image.sun1999.top/20210213231725.png"><br> 上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。<br> 回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。<br> 逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。<br> 有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>
<blockquote>
<p>转自<span class="exturl" data-url="aHR0cDovL3d3dy5tYXRyaXg2Ny5jb20v">Matrix67<i class="fa fa-external-link-alt"></i></span>——<span class="exturl" data-url="aHR0cDovL3d3dy5tYXRyaXg2Ny5jb20vYmxvZy9hcmNoaXZlcy8xMDU=">什么是P问题、NP问题和NPC问题<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年终总结</title>
    <url>/archives/38086.html</url>
    <content><![CDATA[<blockquote>
<p><strong>本文采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzQuMC9kZWVkLnpo">CC BY-NC 4.0<i class="fa fa-external-link-alt"></i></span> 许可协议，您可以自由地分享、演绎该作品，但必须遵循署名、非商业使用、没有附加限制这三项条件。</strong></p>
</blockquote>
<h1 id="一些写在前面的话"><a href="#一些写在前面的话" class="headerlink" title="一些写在前面的话"></a>一些写在前面的话</h1><ol>
<li>首先，确定是否要考研，因为路有很多种：<ul>
<li>对于<strong>计算机相关专业</strong>的同学，我给的建议是<ul>
<li>首先权衡：如果将一天真的能将高强度学习的考研劲头用在找工作上，比如夯实专业课基础，做出拿得出手的项目、多刷leetcode、多背面经、海投简历等等。从我身边的人来看，结果以及回报也会很好。</li>
<li>不像找工作，考研付出多，周期长，只有一次初试，一次复试（也很可能没有）的机会，所以风险高。尤其对于860而言，复试又晚，专业课别的学校也不认可，<strong>基本没得调剂</strong>，所以说必须要有一战成硕的决心；</li>
<li>还有一点就是对于应届生来说除了考研找工作，其实还可以考公，参军，条件允许的话也可以考雅思出国，所以<strong>路真的很多</strong>，做出考研的决定需要<strong>慎重</strong>（我就很草率）；</li>
</ul>
</li>
<li>对于<strong>跨考</strong>的同学，我建议不多，我这里提醒一点：信软的<strong>复试专业问题课程很多</strong>（计组、数据结构、数据库、计网、软工、操作系统），所以说要做好初试结束后就开始好好复习的准备；</li>
<li>对于工作后考研的各位，我觉得压力应该蛮大，很钦佩你们的勇气，同时祝你们得偿所愿！</li>
</ul>
</li>
</ol>
<a id="more"></a>

<ol start="2">
<li>如果决定考研，虽然风险大，但我觉得还是<strong>别给自己留退路</strong>（例如先找一份工作之类的，甚至中途考公、考教资）。因为确实很辛苦，有了回旋的余地的话，在坚持不下去的时候，很可能会想：放松下没事，考不上了还有工作能上。但仅对我自己而言，我认为留后路这种做法会对我的考研决心产生动摇从而不会全力以赴。</li>
<li>由于这段时间已经有学校变更408，而成电并没有消息，所以我个人臆断22年考研专业课应该不会变408。但23年就未可知了，所以说尽量一战成硕，否则如果23改408，二战就会血亏；</li>
<li>如果要开始，4月开始也不算晚，但不要因为学校有课、学校安排实习或别的原因耽搁复习，所以说到底怎么挤时间要自己有打算，总之要<strong>尽力保证每日足够的学习时长</strong>；</li>
<li>就考研而言，我认为<strong>选择比努力更重要</strong>，至少挑一个有信心，且不会炸的专业（就拿成电深圳研究所来说，今年第一年独立招生没人敢报（我就没敢报），全员280，点击就送，但明年究竟如何也未可知；反观今年科软考前都说这专业血赚，然后就被奶炸了。但是也总得努力，线都过不了也没得选；</li>
<li>最后，成电的软工专硕相比其他985的计算机专业来说，相对比较好考，这几年每年大概只涨10分左右，性价比很高，当然西电也是。具体择校需要自己有一个全面的判断；</li>
<li>推荐几个我用的公众号：一烫，考研军火库，给力考研资料，灰灰考研。</li>
</ol>
<h1 id="初试经验"><a href="#初试经验" class="headerlink" title="初试经验"></a>初试经验</h1><p>首先，初试复习的过程蛮难顶的，尽量有一个明确的学习计划，但是我认为每个考研的人心里必须<strong>有一个学习计划</strong>（心里，纸质，电子 都可）。应至少做到计划今天完成什么（每日时间表）以及这个月完成什么（考研进度规划）。像打游戏过任务点一样，自我驱动，而不是学多少算多少，千万别自己骗自己。</p>
<p>下面是我的情况：</p>
<ul>
<li>自己的数学和英语基础很差，而这俩本身也不好学，但是数学分数很高不能放弃，所以说我在数学花了很多的时间，每天4-5h；</li>
<li>英语每天一篇阅读时间在1h，也就马马虎虎的，前期还有1个小时单词书，后期单词的话就晚上宿舍随便背背的百词斩；</li>
<li>由于860专业课我觉得高分不难，虽然区分度不高但是也可以来开差距，所以我一直将专业课排在比较高的优先级，开始的也非常的早，花的时间每天在2-3h；</li>
<li>政治听课+1000题的话要花2h，只听或者只做题只要1h足以；</li>
<li>每天有效学习时间大约在9h左右，尤其是在专业课和政治复习时特别容易走神，需要克服。</li>
<li>我本科是双非计科，学校大三只有很短的生产实习，相对来说复习时间充足，对于时间紧的同学，要自己把握住每天的学习时常；</li>
</ul>
<hr>
<p>以下给出的我的体会以及建议</p>
<ul>
<li><p><strong>政治(71)：</strong></p>
<p>印象里相比别人来说，政治我开始的比较早。主要就是视频徐涛强化，1000题选择3遍，肖四全背，今年卷子全是原题就离谱，花了大把时间在政治（平均每天两小时），最后考71分属实不满意，不知道哪里出了问题，也可能我字太烂了。</p>
<p>建议如下：</p>
<ol>
<li><strong>1000题非常不错</strong>，值得做3遍，所以也应该打印出一个做题的标记本，网上很多的。并且错误选项一定要搞清楚哪里是出的问题。我没有听过腿姐的技巧班，评价还是很高的，但我认为1000题掌握的到位的话，不需要所谓的技巧；</li>
<li>大题的话前中期都不用管，后期肖八的选择好好利用，查漏补缺。大题觉得光肖四不稳的话，肖八的马原大题也可以背，其实<strong>最后背完肖四就行</strong>。我最后花两周时间，每天晚上两小时，把肖四背了两遍；</li>
<li>教材的话建议：精讲精练+1000题+肖四肖八。中后期选择题背书的话，我用了<strong>腿姐的冲刺笔记</strong>，这本册子精炼的同时还很全面；</li>
<li><strong>不建议跟任何带背，不建议看任何押题班</strong>，浪费时间；刷选择APP我不喜欢，不过听说还是有些用。</li>
</ol>
</li>
<li><p><strong>英语(51)：</strong></p>
<p>幸好没报隔壁计院，要不直接没过线，信软里这分数也是倒数，英语从小就拉跨，这考研考的也是真的拉。。背单词是我最早就开始的，背了新东方的恋恋有词两遍，中期做题觉得恋恋有词词汇量不大够，我就买了红宝书背了两遍，黄皮书反复一直在做，但总感觉没有提升。总之，我的英语基础，以及英语学习方式都有很大的问题，所以我也不反向经验了。</p>
</li>
<li><p><strong>数学(105)：</strong></p>
<p>我的数学基础本身不好，花的时间也最长。今年这简单题考105分真的不怎么样，关于我自己出的问题我不多说了，总结一点就是：<strong>考场心态很重要</strong>。</p>
<p>建议如下：</p>
<ol>
<li>我高数基础提高都跟的汤家凤，<strong>1800</strong>做了两遍，第二遍是挑错题做的，但是我认为1800虽然题还行，但是太多了，难以整理，不是很好用。</li>
<li>我1800做了之后就做的<strong>660</strong>，做了100多道没做了，因为感觉做了1800后660的题没啥意思，660的题太抠概念了，过于细</li>
<li>之后就是张宇<strong>1000题</strong>，质量还是蛮高的，但是我开的太晚了，来不及做完，如果没有之前耽搁做1800和660的话，我很推荐</li>
<li>最后就是<strong>数学历年真题全精解析</strong>，金榜那本红书，这本书我刷了3遍，书真的不错，历年真题的横向专题非常实用并且具有针对性，可以很好的把握真题方向，强烈推荐</li>
<li>让我再考一遍的话，我的大概会：<ul>
<li><strong>错题归纳，真的很重要</strong>（有pad会很方便，没有的话应该麻烦点）</li>
<li>高数基础跟汤家凤，提高跟武忠祥</li>
<li>线代李永乐yyds</li>
<li>概率论跟余炳森</li>
<li>做完一遍1800，就去做李林的108两遍，然后就刷历年真题全解红书3遍</li>
<li>李永乐线代讲义，余炳森概率论讲义，这两本书很好，中间可以<strong>反复穿插刷</strong>：</li>
<li>选择题变多了，所以就也可以找找选择题专项做做，武忠祥有个<strong>选择题速成</strong>，我感觉讲的还可以</li>
<li>模拟卷冲刺的时候做就完事了<ol>
<li>李林4+6（100+），我认为是最好的模拟卷，难度适中，最后的李林押题班的题目讲义我也看了一遍，质量也很好；</li>
<li>张宇4（90+），质量很很好，题目虽然难，也有一点超纲，思路很独特，但是不离谱，值得一做；</li>
<li>超越（110+），质量也很好，我觉得不怎么难，可以一做，共创只做了1张，也就和超越差不多；</li>
<li>李永乐6套，质量较差，不推荐。</li>
</ol>
</li>
<li>这里注意一点，21年考纲变了，但是新增的内容我个人感知不强，所以说22的考生应提高警惕</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>专业课(139)：</strong></p>
<p>我自己的情况这里先说下，我课余一直在学javaweb，我大学专业课全靠期末突击，学了忘的很快。我们学校计网是大三上开的（疫情在家网课），软工是大四上开的（期末的时候初试都结束了）。所以说这两门专业课我也没啥基础，我讲这些的意思是：<strong>考860的同学对专业课要有信心！</strong></p>
<p>复习策略：<strong>尽早开始进行专业课，尤其是计网的复习</strong>（我印象里我是在高数基础视频看完之后开始的），而不是说到了最后几个月再冲专业课。由于专业课简单，就可以先学的比较通透，以便可以腾出时间在冲刺阶段有更多的时间准备：软件工程背诵、政治选择考点背诵、肖四背诵、刷数学套卷、英语大小作文练习等等，还有可能要写毕设的开题报告、答辩等等麻烦事。</p>
<p><strong>1）计算机网络</strong></p>
<p>核心：<strong>先理解，再背诵</strong></p>
<ol>
<li>首先计算机网络需要将<strong>黑书</strong>整本书的内容整体看至少3遍，不用做黑书的笔记，但是<strong>一定要看懂！</strong></li>
<li>如果啃书有困难，推荐两个视频：<strong>韩立刚版</strong>（bilibili），虽然是用谢老师的书，但课程深入浅出，理论联系实际，入门真的不错。还有就是哈工大版（中国大学MOOC），有空就看吧，我认为效率不如看书；</li>
<li>黑书的2遍过后，就可以着手看课后的<strong>复习题以及习题</strong>，题目至少三遍，对自己认为重要的题要标注，也可以自己形成笔记本。除了那种一眼都不会考的（比如那种算概率的，做wireshark实验的等等），其余的题尽力搞明白，追求撞大运的同时确实非常帮助理解。黑书答案建议看英文原版，很通俗并不难懂，翻译版机翻的基本没法看；</li>
<li>关于笔记或者说黑书精炼版，<strong>杭电笔记</strong>(中国大学mooc)非常好用，详实并且重点突出，我就是用它作为我中后期复习背诵的主力材料；</li>
<li>很多协议的交互方式看书时一定要弄懂（rdt那里不是重点，但是建议学懂，对tcp的理解有帮助），后期需要对协议的交互进行背诵；</li>
<li>网络的知识点比较琐碎，尤其是安全那里，有空的可以<strong>整理思维导图</strong>，我自己也整理了些思维导图，仅供参考；</li>
<li>这里再提一点，<strong>成电本科计网PPT</strong>基本上包括了其出题的范围，其中除了黑书内容，也包括一定的谢书上的知识（今年考了子网划分），但我建议还是看黑书以追求学习的更加透彻，这也会对复试的一些问题的解答有很大的帮助；</li>
<li>软件定义网络我印象选择中有涉及，但是记不清了，想看就看吧，不是重点；</li>
<li>对于计网的选择题，学懂了自然就会了，没必要专门准备，市面上资料基本没有同样风格的题，倒不如课后题好好做做。</li>
</ol>
<p>  <strong>2）软件工程</strong></p>
<p>  核心<strong>：先背诵，再理解</strong></p>
<ol>
<li>入门：<ol>
<li>黑书没用；</li>
<li>建议<strong>直接看PPT</strong>：mooc的、蓝天老师的、吴晓华老师的都可以，也可以互补着看；</li>
<li>软工基本是文科课程，建议在100天左右开始，不建议听成电软工mooc，各人认为浪费时间；</li>
<li>软工刚开始学的话，可能会感觉一句话读完，你不知道它在说什么。。。所以建议先看PPT，但是要用心去看，看1-2遍以后就会有一个<strong>大概的框架</strong>，如果脑海中没有的话，建议自己整理出大概的框架（根据MOOC的课程目录就可以，或者直接看背诵手册的目录）；</li>
<li>还有一个<strong>软件工程师讲义</strong>（仅仅只能作为入门，看看就行，里面有几个背诵的顺口溜挺好用），相比860的软工更加通俗；</li>
<li>对于<strong>画图题</strong>，考察比较简单，可以灰灰考研的软工视频画图专题(bilibili，微信公众号)，以及吴晓华老师的软工PPT；</li>
</ol>
</li>
<li>在看PPT已经能形成基本的框架之后，接下看就是背诵，<strong>建议直接硬背背诵手册</strong>，背不动的话可以打印PPT背PPT，可以在60天左右的时候开始背，背上一遍再回头看就基本上懂了，应至少背3遍。背诵笔记不全，但应对初试基本够用，今年第一道简答敏捷开发就没背，只能自己乱写，估计扣了好多分，哭了orz;</li>
<li>选择题的话，只要背诵手册好好背，自然就理解并且会做了，同样不用专门训练。</li>
</ol>
<p><strong>3）辅导资料</strong></p>
<ol>
<li>对于860，不建议买任何机构的专业课辅导资料（例如：高分笔记、回忆真题集、本科期末题等等），因为质量真的非常糟糕，我买过红果研的，那是真垃圾，其他的机构，<strong>资料质量普遍较差，并且这些资料群里都有</strong>！不过红果研会员群里上届的学长的讲座还是挺好的，看自己需求，花钱买安心也没啥问题，毕竟也不贵，不过报班可就算了；</li>
<li>建议<strong>买冲刺卷</strong>，这种在考研后期淘宝上就会有上架，大概在100rmb以下。我买过红果研冲刺卷与A+冲刺卷，其中A+冲刺卷质量较高，答案很详实，红果研那个就一般，但是也还可以。好像知博书店还有个pdf的冲刺卷，自己看着买，我感觉A+和红果研以及群里考研班试卷的分享加起来三本卷子已经很足够了。这里注意，市面上的题选择和判断出的都比较扯，和真题风格不同，但也建议一做，大题可以好好练练，也就那些东西，熟悉熟悉试卷结构，就当查漏补缺。这里提一点，<strong>市面上机构本科期末题年代久远，参考价值低，本部应该更有优势</strong></li>
<li>强烈推荐<strong>中国大学mooc成电软件工程的所有习题</strong>，无论是课后练习题还是期末试题。可以将每次开课的题都打出来，在题目网页右键打印可保存pdf。；</li>
<li>860出了这些年我自己感觉都没啥题可出了，所以说原来考过的也要仔细研究清楚，有往年题概率；</li>
<li>搞懂计网<strong>黑书课后题</strong>和<strong>本科PPT中的问题</strong>，软工就<strong>背诵笔记</strong>以及<strong>mooc课后题</strong>。</li>
<li>后期可以对自己不熟悉的点专门摘抄到一起，专门加强记忆，3元本子足以，有pad更方便。</li>
</ol>
</li>
</ul>
<h1 id="复试经验（266）"><a href="#复试经验（266）" class="headerlink" title="复试经验（266）"></a><strong>复试经验（266）</strong></h1><ol>
<li><strong>务必敬畏诚信复试承诺书</strong></li>
<li><strong>复试非常公平</strong>，成电信软的复试非常公平，就我个人的面试结果而言，成电老师且<strong>对双非并不歧视</strong>，英语面和综面中丝毫没有刁难我的意思。所以说对于踩线的同学，复试只管好好准备，大家都很有机会；</li>
<li>关于复习时间，我自己大概花了一个半月，我专业课基础也比较差，时间上我觉得正合适，总之要根据自己的实际情况<strong>合理安排准备复试的时间</strong>；</li>
<li>关于<strong>英语自我介绍，建议硬背</strong>，越熟越好，最好能熟到无意识的背出。介绍和英语问题我每天背大约2-3h左右，坚持了3周。自我介绍建议参考一些模板问候语，转折语。具体内容自己写，不会的软件翻译，背的过程中慢慢修改，可以写成电子版以便修改；</li>
<li>对自己听力不自信的可以看美剧，权当娱乐时磨耳朵也行（从开始准备复试到复试头天晚上，老友记我从第一季看到了第六季，当然还是因为好看。。。）。不过这里注意：英语面是信软自己的老师，有点不标准但足够清晰，且语速很慢，个人认为容易听懂；</li>
<li>专业课分数占比低，但是区分度大，很重要；</li>
<li><strong>计组</strong>强烈吴晓华老师<strong>PPT</strong>，操作系统也可参考本科PPT；数据库的话除了高教的红书，可以再了解下<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9tb25nb2RiL25vc3FsLmh0bWw=">NoSQL<i class="fa fa-external-link-alt"></i></span>，说的这些其实也是我自己用过的专业课复习资料，群里也有些题可以自行整理。</li>
<li><strong>综面</strong>考察非常开放、综合，<strong>分数也更大</strong>，这里建议自行了解人工智能、大数据、物联网、云计算、智慧医疗、脑机接口等前沿领域的概念、应用以及前景，形成自己的思考。</li>
<li><strong>简历</strong>可以<strong>引导老师综面的提问</strong>，也正是如此，个人简历千万不要往上面写不会的，简历实在没啥写的直接就不要交简历，<strong>乱吹可能会翻车</strong>；</li>
<li>最重要的是：面试技巧。比如老师专业面时如果这题你不会，那也<strong>一定要说话，只要沾边，老师都会给分</strong>。试想有的老师是做嵌入式的，有的是做机器学习的，有的是做云计算的，一组中很可能没有老师搞嵌入式的，那其他老师的计组这么多年也都忘了很多了。比如专业问题若抽到问个某个机制的流程这种比较细的问题，很可能好几个老师自己也不知道正确答案，那么老师听你讲的有理便就不会在分数上为难你。所以说一定要说话（相关的就可以，但不要乱讲，<strong>乱讲必翻车</strong>），我觉得<strong>要是直接说我不会，老师想给都给不了你分</strong>，这点在综面中同理。关于面试的技巧还可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9ncm91cC90b3BpYy8yMTk4NDc1MzUv">豆瓣上的一篇文章<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h1 id="导师志愿"><a href="#导师志愿" class="headerlink" title="导师志愿"></a>导师志愿</h1><ol>
<li>学校的导师志愿是在复试前需要选定的；</li>
<li>导师<strong>只有第一志愿有用</strong>，其他选项四个是充数的，只有第一志愿老师那边只能收到你的志愿信息，所以联系第一志愿导师非常重要；</li>
<li>如果第一志愿导师名额不够，优先导师团队内部会尝试调配你到导师团队的其他导师，所以再次提醒：尽早联系第一志愿导师；</li>
<li>如果都满了，就到了双选阶段（抢人阶段）：如果你分数还可以，那就可能会有你不认识的老师给你主动打电话，你当然也可以积极主动联系其他老师询问是否还有名额；</li>
<li>双选没选上应该就等开学了，这个我不清楚，总之都有学上；</li>
<li>建议<strong>通过电话（自己想办法要到）联系</strong>而非邮件，电话效率比邮件不知道高到哪里去了，老师人都炒鸡好的。有电话的直接给老师打电话，胆子放大，但一定一定要有礼貌；</li>
<li>推免名额已满的导师依旧会出现在志愿系统中，这要选成了第一志愿，那就巨吃亏；</li>
<li>网上评价较少的导师其实很多都挺nice的；</li>
<li>没回你邮件的导师一定不要选为第一志愿；</li>
<li>本部优势巨大；</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tnY28vUmF0ZU15U3VwZXJ2aXNvcg==">RateMySupervisor<i class="fa fa-external-link-alt"></i></span>（可能要梯），我觉得其中信息比较片面且主观，自行把握：</li>
<li>该板块经验非常主观，并且不一定对。我也不解答关于此板块的问题，大家看看就好。</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>因人大那事，本经验贴中也删了不少细节，想了想还是发出来吧</p>
</blockquote>
<p>以上提到的所有资料均在公益群：<code>438081068</code> 中免费分享。我也是潜水员，不过群的氛围真的很好，也给我了莫大的帮助。怀着投我以木桃，报之以琼瑶的心情断断续续写了很久，六千余字，肺腑之言。很希望能对各位的考研有所帮助，少走弯路，也很希望将来的小伙伴也在积极群中分享自己的资料以及经验心得，<strong>但再次提醒，大家一定敬畏规则</strong>。</p>
<p>提醒一点，本文中的个人看法非常主观，所有的经验终究是别人的经验，<strong>学习方法也有很多，最适合你的才是最好的</strong>。</p>
<p>预祝各位考研成功！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
